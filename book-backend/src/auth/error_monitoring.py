"""
Authentication error monitoring and alerting system.
"""

import logging
import time
import json
from typing import Dict, Any, List, Optional, Callable
from datetime import datetime, timedelta
from collections import defaultdict, deque
from dataclasses import dataclass, asdict
from enum import Enum
import asyncio
import smtplib
from email.mime.text import MimeText
from email.mime.multipart import MimeMultipart

logger = logging.getLogger(__name__)


class AlertLevel(str, Enum):
    \"\"\"Alert severity levels.\"\"\"\n    INFO = \"info\"\n    WARNING = \"warning\"\n    ERROR = \"error\"\n    CRITICAL = \"critical\"\n\n\n@dataclass\nclass SecurityAlert:\n    \"\"\"Security alert data structure.\"\"\"\n    alert_id: str\n    alert_type: str\n    level: AlertLevel\n    message: str\n    details: Dict[str, Any]\n    timestamp: float\n    source: str\n    affected_user: Optional[str] = None\n    client_ip: Optional[str] = None\n    user_agent: Optional[str] = None\n    resolved: bool = False\n    resolution_notes: Optional[str] = None\n\n\nclass SecurityMetrics:\n    \"\"\"Security metrics tracking.\"\"\"\n    \n    def __init__(self, window_size: int = 3600):  # 1 hour window\n        self.window_size = window_size\n        self.failed_logins = deque()\n        self.successful_logins = deque()\n        self.rate_limit_violations = deque()\n        self.security_violations = deque()\n        self.token_errors = deque()\n        self.permission_denials = deque()\n        \n        # Counters\n        self.total_failed_logins = 0\n        self.total_successful_logins = 0\n        self.total_rate_limit_violations = 0\n        self.total_security_violations = 0\n        self.total_token_errors = 0\n        self.total_permission_denials = 0\n        \n        # User-specific tracking\n        self.user_failed_attempts = defaultdict(list)\n        self.ip_failed_attempts = defaultdict(list)\n        \n        # Suspicious patterns\n        self.suspicious_ips = set()\n        self.suspicious_users = set()\n    \n    def record_failed_login(self, user_id: Optional[str], client_ip: str, user_agent: str) -> None:\n        \"\"\"Record a failed login attempt.\"\"\"\n        timestamp = time.time()\n        \n        event = {\n            'timestamp': timestamp,\n            'user_id': user_id,\n            'client_ip': client_ip,\n            'user_agent': user_agent\n        }\n        \n        self.failed_logins.append(event)\n        self.total_failed_logins += 1\n        \n        # Track by user and IP\n        if user_id:\n            self.user_failed_attempts[user_id].append(timestamp)\n        self.ip_failed_attempts[client_ip].append(timestamp)\n        \n        # Clean old entries\n        self._clean_old_entries()\n        \n        # Check for suspicious patterns\n        self._check_suspicious_patterns(user_id, client_ip)\n    \n    def record_successful_login(self, user_id: str, client_ip: str, user_agent: str) -> None:\n        \"\"\"Record a successful login.\"\"\"\n        timestamp = time.time()\n        \n        event = {\n            'timestamp': timestamp,\n            'user_id': user_id,\n            'client_ip': client_ip,\n            'user_agent': user_agent\n        }\n        \n        self.successful_logins.append(event)\n        self.total_successful_logins += 1\n        \n        # Clean old entries\n        self._clean_old_entries()\n    \n    def record_rate_limit_violation(self, client_ip: str, endpoint: str, user_agent: str) -> None:\n        \"\"\"Record a rate limit violation.\"\"\"\n        timestamp = time.time()\n        \n        event = {\n            'timestamp': timestamp,\n            'client_ip': client_ip,\n            'endpoint': endpoint,\n            'user_agent': user_agent\n        }\n        \n        self.rate_limit_violations.append(event)\n        self.total_rate_limit_violations += 1\n        \n        # Track by IP\n        self.ip_failed_attempts[client_ip].append(timestamp)\n        \n        # Clean old entries\n        self._clean_old_entries()\n    \n    def record_security_violation(self, violation_type: str, client_ip: str, details: Dict[str, Any]) -> None:\n        \"\"\"Record a security violation.\"\"\"\n        timestamp = time.time()\n        \n        event = {\n            'timestamp': timestamp,\n            'violation_type': violation_type,\n            'client_ip': client_ip,\n            'details': details\n        }\n        \n        self.security_violations.append(event)\n        self.total_security_violations += 1\n        \n        # Mark IP as suspicious\n        self.suspicious_ips.add(client_ip)\n        \n        # Clean old entries\n        self._clean_old_entries()\n    \n    def record_token_error(self, error_type: str, user_id: Optional[str], client_ip: str) -> None:\n        \"\"\"Record a token-related error.\"\"\"\n        timestamp = time.time()\n        \n        event = {\n            'timestamp': timestamp,\n            'error_type': error_type,\n            'user_id': user_id,\n            'client_ip': client_ip\n        }\n        \n        self.token_errors.append(event)\n        self.total_token_errors += 1\n        \n        # Clean old entries\n        self._clean_old_entries()\n    \n    def record_permission_denial(self, user_id: str, resource: str, client_ip: str) -> None:\n        \"\"\"Record a permission denial.\"\"\"\n        timestamp = time.time()\n        \n        event = {\n            'timestamp': timestamp,\n            'user_id': user_id,\n            'resource': resource,\n            'client_ip': client_ip\n        }\n        \n        self.permission_denials.append(event)\n        self.total_permission_denials += 1\n        \n        # Clean old entries\n        self._clean_old_entries()\n    \n    def _clean_old_entries(self) -> None:\n        \"\"\"Remove entries older than the window size.\"\"\"\n        current_time = time.time()\n        cutoff_time = current_time - self.window_size\n        \n        # Clean deques\n        for deque_obj in [self.failed_logins, self.successful_logins, \n                         self.rate_limit_violations, self.security_violations,\n                         self.token_errors, self.permission_denials]:\n            while deque_obj and deque_obj[0]['timestamp'] < cutoff_time:\n                deque_obj.popleft()\n        \n        # Clean user and IP tracking\n        for user_id in list(self.user_failed_attempts.keys()):\n            self.user_failed_attempts[user_id] = [\n                t for t in self.user_failed_attempts[user_id] if t > cutoff_time\n            ]\n            if not self.user_failed_attempts[user_id]:\n                del self.user_failed_attempts[user_id]\n        \n        for ip in list(self.ip_failed_attempts.keys()):\n            self.ip_failed_attempts[ip] = [\n                t for t in self.ip_failed_attempts[ip] if t > cutoff_time\n            ]\n            if not self.ip_failed_attempts[ip]:\n                del self.ip_failed_attempts[ip]\n    \n    def _check_suspicious_patterns(self, user_id: Optional[str], client_ip: str) -> None:\n        \"\"\"Check for suspicious patterns and mark users/IPs.\"\"\"\n        current_time = time.time()\n        recent_window = 300  # 5 minutes\n        \n        # Check for too many failed attempts from IP\n        if client_ip in self.ip_failed_attempts:\n            recent_failures = [\n                t for t in self.ip_failed_attempts[client_ip]\n                if t > current_time - recent_window\n            ]\n            if len(recent_failures) >= 10:  # 10 failures in 5 minutes\n                self.suspicious_ips.add(client_ip)\n        \n        # Check for too many failed attempts for user\n        if user_id and user_id in self.user_failed_attempts:\n            recent_failures = [\n                t for t in self.user_failed_attempts[user_id]\n                if t > current_time - recent_window\n            ]\n            if len(recent_failures) >= 5:  # 5 failures in 5 minutes\n                self.suspicious_users.add(user_id)\n    \n    def get_metrics(self) -> Dict[str, Any]:\n        \"\"\"Get current security metrics.\"\"\"\n        current_time = time.time()\n        window_start = current_time - self.window_size\n        \n        return {\n            'window_size_hours': self.window_size / 3600,\n            'current_window': {\n                'failed_logins': len(self.failed_logins),\n                'successful_logins': len(self.successful_logins),\n                'rate_limit_violations': len(self.rate_limit_violations),\n                'security_violations': len(self.security_violations),\n                'token_errors': len(self.token_errors),\n                'permission_denials': len(self.permission_denials),\n            },\n            'totals': {\n                'failed_logins': self.total_failed_logins,\n                'successful_logins': self.total_successful_logins,\n                'rate_limit_violations': self.total_rate_limit_violations,\n                'security_violations': self.total_security_violations,\n                'token_errors': self.total_token_errors,\n                'permission_denials': self.total_permission_denials,\n            },\n            'suspicious_activity': {\n                'suspicious_ips': list(self.suspicious_ips),\n                'suspicious_users': list(self.suspicious_users),\n                'top_failing_ips': self._get_top_failing_ips(),\n                'top_failing_users': self._get_top_failing_users(),\n            },\n            'success_rate': self._calculate_success_rate(),\n        }\n    \n    def _get_top_failing_ips(self, limit: int = 10) -> List[Dict[str, Any]]:\n        \"\"\"Get top IPs with most failures.\"\"\"\n        ip_counts = {}\n        for ip, timestamps in self.ip_failed_attempts.items():\n            ip_counts[ip] = len(timestamps)\n        \n        return [\n            {'ip': ip, 'failures': count}\n            for ip, count in sorted(ip_counts.items(), key=lambda x: x[1], reverse=True)[:limit]\n        ]\n    \n    def _get_top_failing_users(self, limit: int = 10) -> List[Dict[str, Any]]:\n        \"\"\"Get top users with most failures.\"\"\"\n        user_counts = {}\n        for user_id, timestamps in self.user_failed_attempts.items():\n            user_counts[user_id] = len(timestamps)\n        \n        return [\n            {'user_id': user_id, 'failures': count}\n            for user_id, count in sorted(user_counts.items(), key=lambda x: x[1], reverse=True)[:limit]\n        ]\n    \n    def _calculate_success_rate(self) -> float:\n        \"\"\"Calculate login success rate.\"\"\"\n        total_attempts = len(self.failed_logins) + len(self.successful_logins)\n        if total_attempts == 0:\n            return 1.0\n        return len(self.successful_logins) / total_attempts\n\n\nclass SecurityAlertManager:\n    \"\"\"Manages security alerts and notifications.\"\"\"\n    \n    def __init__(self):\n        self.alerts = []\n        self.alert_handlers = []\n        self.max_alerts = 10000\n        \n        # Alert thresholds\n        self.thresholds = {\n            'failed_logins_per_minute': 10,\n            'rate_limit_violations_per_minute': 5,\n            'security_violations_per_hour': 3,\n            'suspicious_ips_threshold': 5,\n            'success_rate_threshold': 0.5,  # Below 50% success rate\n        }\n    \n    def add_alert_handler(self, handler: Callable[[SecurityAlert], None]) -> None:\n        \"\"\"Add an alert handler function.\"\"\"\n        self.alert_handlers.append(handler)\n    \n    def create_alert(\n        self,\n        alert_type: str,\n        level: AlertLevel,\n        message: str,\n        details: Dict[str, Any],\n        source: str = \"auth_system\",\n        affected_user: Optional[str] = None,\n        client_ip: Optional[str] = None,\n        user_agent: Optional[str] = None\n    ) -> SecurityAlert:\n        \"\"\"Create and process a security alert.\"\"\"\n        \n        alert = SecurityAlert(\n            alert_id=f\"alert_{int(time.time())}_{len(self.alerts)}\",\n            alert_type=alert_type,\n            level=level,\n            message=message,\n            details=details,\n            timestamp=time.time(),\n            source=source,\n            affected_user=affected_user,\n            client_ip=client_ip,\n            user_agent=user_agent\n        )\n        \n        # Add to alerts list\n        self.alerts.append(alert)\n        \n        # Keep alerts list manageable\n        if len(self.alerts) > self.max_alerts:\n            self.alerts = self.alerts[-self.max_alerts:]\n        \n        # Log alert\n        self._log_alert(alert)\n        \n        # Notify handlers\n        self._notify_handlers(alert)\n        \n        return alert\n    \n    def check_metrics_for_alerts(self, metrics: SecurityMetrics) -> List[SecurityAlert]:\n        \"\"\"Check security metrics and create alerts if thresholds are exceeded.\"\"\"\n        alerts = []\n        current_metrics = metrics.get_metrics()\n        \n        # Check failed logins rate\n        failed_logins_per_minute = len(metrics.failed_logins) / (metrics.window_size / 60)\n        if failed_logins_per_minute > self.thresholds['failed_logins_per_minute']:\n            alert = self.create_alert(\n                alert_type=\"high_failed_login_rate\",\n                level=AlertLevel.WARNING,\n                message=f\"High failed login rate: {failed_logins_per_minute:.1f} per minute\",\n                details={\n                    \"rate\": failed_logins_per_minute,\n                    \"threshold\": self.thresholds['failed_logins_per_minute'],\n                    \"window_hours\": metrics.window_size / 3600\n                }\n            )\n            alerts.append(alert)\n        \n        # Check rate limit violations\n        rate_limit_violations_per_minute = len(metrics.rate_limit_violations) / (metrics.window_size / 60)\n        if rate_limit_violations_per_minute > self.thresholds['rate_limit_violations_per_minute']:\n            alert = self.create_alert(\n                alert_type=\"high_rate_limit_violations\",\n                level=AlertLevel.WARNING,\n                message=f\"High rate limit violation rate: {rate_limit_violations_per_minute:.1f} per minute\",\n                details={\n                    \"rate\": rate_limit_violations_per_minute,\n                    \"threshold\": self.thresholds['rate_limit_violations_per_minute']\n                }\n            )\n            alerts.append(alert)\n        \n        # Check security violations\n        security_violations_per_hour = len(metrics.security_violations)\n        if security_violations_per_hour > self.thresholds['security_violations_per_hour']:\n            alert = self.create_alert(\n                alert_type=\"high_security_violations\",\n                level=AlertLevel.ERROR,\n                message=f\"High security violation rate: {security_violations_per_hour} per hour\",\n                details={\n                    \"count\": security_violations_per_hour,\n                    \"threshold\": self.thresholds['security_violations_per_hour']\n                }\n            )\n            alerts.append(alert)\n        \n        # Check suspicious IPs\n        if len(metrics.suspicious_ips) > self.thresholds['suspicious_ips_threshold']:\n            alert = self.create_alert(\n                alert_type=\"multiple_suspicious_ips\",\n                level=AlertLevel.ERROR,\n                message=f\"Multiple suspicious IPs detected: {len(metrics.suspicious_ips)}\",\n                details={\n                    \"suspicious_ips\": list(metrics.suspicious_ips),\n                    \"count\": len(metrics.suspicious_ips),\n                    \"threshold\": self.thresholds['suspicious_ips_threshold']\n                }\n            )\n            alerts.append(alert)\n        \n        # Check success rate\n        success_rate = current_metrics['success_rate']\n        if success_rate < self.thresholds['success_rate_threshold']:\n            alert = self.create_alert(\n                alert_type=\"low_success_rate\",\n                level=AlertLevel.WARNING,\n                message=f\"Low login success rate: {success_rate:.1%}\",\n                details={\n                    \"success_rate\": success_rate,\n                    \"threshold\": self.thresholds['success_rate_threshold'],\n                    \"failed_logins\": len(metrics.failed_logins),\n                    \"successful_logins\": len(metrics.successful_logins)\n                }\n            )\n            alerts.append(alert)\n        \n        return alerts\n    \n    def _log_alert(self, alert: SecurityAlert) -> None:\n        \"\"\"Log security alert.\"\"\"\n        log_data = {\n            \"alert_id\": alert.alert_id,\n            \"alert_type\": alert.alert_type,\n            \"level\": alert.level,\n            \"message\": alert.message,\n            \"source\": alert.source,\n            \"timestamp\": alert.timestamp,\n        }\n        \n        if alert.affected_user:\n            log_data[\"affected_user\"] = alert.affected_user\n        \n        if alert.client_ip:\n            log_data[\"client_ip\"] = alert.client_ip\n        \n        if alert.details:\n            log_data[\"details\"] = alert.details\n        \n        # Log with appropriate level\n        if alert.level == AlertLevel.CRITICAL:\n            logger.critical(f\"SECURITY ALERT: {log_data}\")\n        elif alert.level == AlertLevel.ERROR:\n            logger.error(f\"Security Alert: {log_data}\")\n        elif alert.level == AlertLevel.WARNING:\n            logger.warning(f\"Security Alert: {log_data}\")\n        else:\n            logger.info(f\"Security Alert: {log_data}\")\n    \n    def _notify_handlers(self, alert: SecurityAlert) -> None:\n        \"\"\"Notify all registered alert handlers.\"\"\"\n        for handler in self.alert_handlers:\n            try:\n                handler(alert)\n            except Exception as e:\n                logger.error(f\"Error in alert handler: {e}\")\n    \n    def get_recent_alerts(self, hours: int = 24, level: Optional[AlertLevel] = None) -> List[SecurityAlert]:\n        \"\"\"Get recent alerts within specified time frame.\"\"\"\n        cutoff_time = time.time() - (hours * 3600)\n        \n        alerts = [alert for alert in self.alerts if alert.timestamp > cutoff_time]\n        \n        if level:\n            alerts = [alert for alert in alerts if alert.level == level]\n        \n        return sorted(alerts, key=lambda x: x.timestamp, reverse=True)\n    \n    def resolve_alert(self, alert_id: str, resolution_notes: str) -> bool:\n        \"\"\"Mark an alert as resolved.\"\"\"\n        for alert in self.alerts:\n            if alert.alert_id == alert_id:\n                alert.resolved = True\n                alert.resolution_notes = resolution_notes\n                logger.info(f\"Alert {alert_id} resolved: {resolution_notes}\")\n                return True\n        return False\n    \n    def get_alert_summary(self) -> Dict[str, Any]:\n        \"\"\"Get summary of alerts.\"\"\"\n        recent_alerts = self.get_recent_alerts(24)\n        \n        level_counts = defaultdict(int)\n        type_counts = defaultdict(int)\n        resolved_count = 0\n        \n        for alert in recent_alerts:\n            level_counts[alert.level.value] += 1\n            type_counts[alert.alert_type] += 1\n            if alert.resolved:\n                resolved_count += 1\n        \n        return {\n            \"total_alerts_24h\": len(recent_alerts),\n            \"resolved_alerts_24h\": resolved_count,\n            \"unresolved_alerts_24h\": len(recent_alerts) - resolved_count,\n            \"alerts_by_level\": dict(level_counts),\n            \"alerts_by_type\": dict(type_counts),\n            \"most_recent_alert\": {\n                \"timestamp\": recent_alerts[0].timestamp,\n                \"type\": recent_alerts[0].alert_type,\n                \"level\": recent_alerts[0].level,\n                \"message\": recent_alerts[0].message\n            } if recent_alerts else None\n        }\n\n\nclass SecurityMonitor:\n    \"\"\"Main security monitoring system.\"\"\"\n    \n    def __init__(self):\n        self.metrics = SecurityMetrics()\n        self.alert_manager = SecurityAlertManager()\n        self.monitoring_active = False\n        self.check_interval = 60  # Check every minute\n        \n        # Set up default alert handlers\n        self.alert_manager.add_alert_handler(self._default_alert_handler)\n    \n    def start_monitoring(self) -> None:\n        \"\"\"Start the security monitoring system.\"\"\"\n        if self.monitoring_active:\n            return\n        \n        self.monitoring_active = True\n        logger.info(\"Security monitoring started\")\n        \n        # Start monitoring loop\n        asyncio.create_task(self._monitoring_loop())\n    \n    def stop_monitoring(self) -> None:\n        \"\"\"Stop the security monitoring system.\"\"\"\n        self.monitoring_active = False\n        logger.info(\"Security monitoring stopped\")\n    \n    async def _monitoring_loop(self) -> None:\n        \"\"\"Main monitoring loop.\"\"\"\n        while self.monitoring_active:\n            try:\n                # Check metrics and create alerts\n                alerts = self.alert_manager.check_metrics_for_alerts(self.metrics)\n                \n                if alerts:\n                    logger.info(f\"Generated {len(alerts)} security alerts\")\n                \n                # Wait for next check\n                await asyncio.sleep(self.check_interval)\n                \n            except Exception as e:\n                logger.error(f\"Error in security monitoring loop: {e}\")\n                await asyncio.sleep(self.check_interval)\n    \n    def _default_alert_handler(self, alert: SecurityAlert) -> None:\n        \"\"\"Default alert handler that logs critical alerts.\"\"\"\n        if alert.level == AlertLevel.CRITICAL:\n            # In production, this could send emails, Slack messages, etc.\n            logger.critical(f\"CRITICAL SECURITY ALERT: {alert.message}\")\n    \n    def get_security_dashboard(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive security dashboard data.\"\"\"\n        return {\n            \"metrics\": self.metrics.get_metrics(),\n            \"alerts\": self.alert_manager.get_alert_summary(),\n            \"monitoring_status\": {\n                \"active\": self.monitoring_active,\n                \"check_interval\": self.check_interval,\n                \"uptime\": time.time() - getattr(self, '_start_time', time.time())\n            }\n        }\n\n\n# Global security monitor instance\nsecurity_monitor = SecurityMonitor()\n\n\n# Convenience functions\ndef record_failed_login(user_id: Optional[str], client_ip: str, user_agent: str) -> None:\n    \"\"\"Record a failed login attempt.\"\"\"\n    security_monitor.metrics.record_failed_login(user_id, client_ip, user_agent)\n\n\ndef record_successful_login(user_id: str, client_ip: str, user_agent: str) -> None:\n    \"\"\"Record a successful login.\"\"\"\n    security_monitor.metrics.record_successful_login(user_id, client_ip, user_agent)\n\n\ndef record_security_violation(violation_type: str, client_ip: str, details: Dict[str, Any]) -> None:\n    \"\"\"Record a security violation.\"\"\"\n    security_monitor.metrics.record_security_violation(violation_type, client_ip, details)\n\n\ndef create_security_alert(alert_type: str, level: AlertLevel, message: str, details: Dict[str, Any]) -> SecurityAlert:\n    \"\"\"Create a security alert.\"\"\"\n    return security_monitor.alert_manager.create_alert(alert_type, level, message, details)\n\n\ndef get_security_metrics() -> Dict[str, Any]:\n    \"\"\"Get current security metrics.\"\"\"\n    return security_monitor.metrics.get_metrics()\n\n\ndef get_security_dashboard() -> Dict[str, Any]:\n    \"\"\"Get security dashboard data.\"\"\"\n    return security_monitor.get_security_dashboard()\n"