"""
Comprehensive authentication error handling system.
"""

import logging
import time
import traceback
from typing import Dict, Any, Optional, List
from enum import Enum
from fastapi import HTTPException, status, Request
from fastapi.responses import JSONResponse
from pydantic import BaseModel
import uuid

logger = logging.getLogger(__name__)


class AuthErrorType(str, Enum):
    \"\"\"Authentication error types.\"\"\"\n    INVALID_CREDENTIALS = \"invalid_credentials\"\n    TOKEN_EXPIRED = \"token_expired\"\n    TOKEN_INVALID = \"token_invalid\"\n    TOKEN_MISSING = \"token_missing\"\n    USER_NOT_FOUND = \"user_not_found\"\n    USER_INACTIVE = \"user_inactive\"\n    USER_LOCKED = \"user_locked\"\n    PERMISSION_DENIED = \"permission_denied\"\n    RATE_LIMIT_EXCEEDED = \"rate_limit_exceeded\"\n    SESSION_EXPIRED = \"session_expired\"\n    CSRF_TOKEN_INVALID = \"csrf_token_invalid\"\n    PASSWORD_WEAK = \"password_weak\"\n    EMAIL_INVALID = \"email_invalid\"\n    SIGNUP_FAILED = \"signup_failed\"\n    LOGIN_FAILED = \"login_failed\"\n    LOGOUT_FAILED = \"logout_failed\"\n    REFRESH_FAILED = \"refresh_failed\"\n    PROFILE_UPDATE_FAILED = \"profile_update_failed\"\n    PASSWORD_RESET_FAILED = \"password_reset_failed\"\n    ACCOUNT_VERIFICATION_FAILED = \"account_verification_failed\"\n    TWO_FACTOR_REQUIRED = \"two_factor_required\"\n    TWO_FACTOR_INVALID = \"two_factor_invalid\"\n    SECURITY_VIOLATION = \"security_violation\"\n    INTERNAL_ERROR = \"internal_error\"\n\n\nclass AuthErrorSeverity(str, Enum):\n    \"\"\"Error severity levels.\"\"\"\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n    CRITICAL = \"critical\"\n\n\nclass AuthErrorResponse(BaseModel):\n    \"\"\"Standardized authentication error response.\"\"\"\n    error_id: str\n    error_type: AuthErrorType\n    error_code: str\n    message: str\n    details: Optional[Dict[str, Any]] = None\n    timestamp: int\n    request_id: Optional[str] = None\n    retry_after: Optional[int] = None\n    help_url: Optional[str] = None\n\n\nclass AuthError(Exception):\n    \"\"\"Custom authentication error class.\"\"\"\n    \n    def __init__(\n        self,\n        error_type: AuthErrorType,\n        message: str,\n        details: Optional[Dict[str, Any]] = None,\n        status_code: int = status.HTTP_401_UNAUTHORIZED,\n        severity: AuthErrorSeverity = AuthErrorSeverity.MEDIUM,\n        retry_after: Optional[int] = None,\n        help_url: Optional[str] = None,\n        log_level: int = logging.WARNING\n    ):\n        self.error_type = error_type\n        self.message = message\n        self.details = details or {}\n        self.status_code = status_code\n        self.severity = severity\n        self.retry_after = retry_after\n        self.help_url = help_url\n        self.log_level = log_level\n        self.error_id = str(uuid.uuid4())[:8]\n        self.timestamp = int(time.time())\n        \n        super().__init__(message)\n\n\nclass AuthErrorHandler:\n    \"\"\"Comprehensive authentication error handler.\"\"\"\n    \n    def __init__(self):\n        self.error_counts = {}  # Track error counts for monitoring\n        self.error_history = []  # Keep recent error history\n        self.max_history = 1000\n        \n        # Error type to status code mapping\n        self.error_status_mapping = {\n            AuthErrorType.INVALID_CREDENTIALS: status.HTTP_401_UNAUTHORIZED,\n            AuthErrorType.TOKEN_EXPIRED: status.HTTP_401_UNAUTHORIZED,\n            AuthErrorType.TOKEN_INVALID: status.HTTP_401_UNAUTHORIZED,\n            AuthErrorType.TOKEN_MISSING: status.HTTP_401_UNAUTHORIZED,\n            AuthErrorType.USER_NOT_FOUND: status.HTTP_401_UNAUTHORIZED,\n            AuthErrorType.USER_INACTIVE: status.HTTP_403_FORBIDDEN,\n            AuthErrorType.USER_LOCKED: status.HTTP_423_LOCKED,\n            AuthErrorType.PERMISSION_DENIED: status.HTTP_403_FORBIDDEN,\n            AuthErrorType.RATE_LIMIT_EXCEEDED: status.HTTP_429_TOO_MANY_REQUESTS,\n            AuthErrorType.SESSION_EXPIRED: status.HTTP_401_UNAUTHORIZED,\n            AuthErrorType.CSRF_TOKEN_INVALID: status.HTTP_403_FORBIDDEN,\n            AuthErrorType.PASSWORD_WEAK: status.HTTP_400_BAD_REQUEST,\n            AuthErrorType.EMAIL_INVALID: status.HTTP_400_BAD_REQUEST,\n            AuthErrorType.SIGNUP_FAILED: status.HTTP_400_BAD_REQUEST,\n            AuthErrorType.LOGIN_FAILED: status.HTTP_401_UNAUTHORIZED,\n            AuthErrorType.LOGOUT_FAILED: status.HTTP_500_INTERNAL_SERVER_ERROR,\n            AuthErrorType.REFRESH_FAILED: status.HTTP_401_UNAUTHORIZED,\n            AuthErrorType.PROFILE_UPDATE_FAILED: status.HTTP_400_BAD_REQUEST,\n            AuthErrorType.PASSWORD_RESET_FAILED: status.HTTP_400_BAD_REQUEST,\n            AuthErrorType.ACCOUNT_VERIFICATION_FAILED: status.HTTP_400_BAD_REQUEST,\n            AuthErrorType.TWO_FACTOR_REQUIRED: status.HTTP_401_UNAUTHORIZED,\n            AuthErrorType.TWO_FACTOR_INVALID: status.HTTP_401_UNAUTHORIZED,\n            AuthErrorType.SECURITY_VIOLATION: status.HTTP_403_FORBIDDEN,\n            AuthErrorType.INTERNAL_ERROR: status.HTTP_500_INTERNAL_SERVER_ERROR,\n        }\n        \n        # User-friendly error messages\n        self.user_messages = {\n            AuthErrorType.INVALID_CREDENTIALS: \"Invalid email or password. Please try again.\",\n            AuthErrorType.TOKEN_EXPIRED: \"Your session has expired. Please log in again.\",\n            AuthErrorType.TOKEN_INVALID: \"Invalid authentication token. Please log in again.\",\n            AuthErrorType.TOKEN_MISSING: \"Authentication required. Please log in.\",\n            AuthErrorType.USER_NOT_FOUND: \"Invalid email or password. Please try again.\",\n            AuthErrorType.USER_INACTIVE: \"Your account is inactive. Please contact support.\",\n            AuthErrorType.USER_LOCKED: \"Your account has been locked. Please contact support.\",\n            AuthErrorType.PERMISSION_DENIED: \"You don't have permission to access this resource.\",\n            AuthErrorType.RATE_LIMIT_EXCEEDED: \"Too many requests. Please try again later.\",\n            AuthErrorType.SESSION_EXPIRED: \"Your session has expired. Please log in again.\",\n            AuthErrorType.CSRF_TOKEN_INVALID: \"Security token invalid. Please refresh and try again.\",\n            AuthErrorType.PASSWORD_WEAK: \"Password does not meet security requirements.\",\n            AuthErrorType.EMAIL_INVALID: \"Please enter a valid email address.\",\n            AuthErrorType.SIGNUP_FAILED: \"Account creation failed. Please try again.\",\n            AuthErrorType.LOGIN_FAILED: \"Login failed. Please check your credentials.\",\n            AuthErrorType.LOGOUT_FAILED: \"Logout failed. Please try again.\",\n            AuthErrorType.REFRESH_FAILED: \"Session refresh failed. Please log in again.\",\n            AuthErrorType.PROFILE_UPDATE_FAILED: \"Profile update failed. Please try again.\",\n            AuthErrorType.PASSWORD_RESET_FAILED: \"Password reset failed. Please try again.\",\n            AuthErrorType.ACCOUNT_VERIFICATION_FAILED: \"Account verification failed. Please try again.\",\n            AuthErrorType.TWO_FACTOR_REQUIRED: \"Two-factor authentication required.\",\n            AuthErrorType.TWO_FACTOR_INVALID: \"Invalid two-factor authentication code.\",\n            AuthErrorType.SECURITY_VIOLATION: \"Security violation detected. Access denied.\",\n            AuthErrorType.INTERNAL_ERROR: \"An internal error occurred. Please try again later.\",\n        }\n        \n        # Help URLs for different error types\n        self.help_urls = {\n            AuthErrorType.PASSWORD_WEAK: \"/help/password-requirements\",\n            AuthErrorType.TWO_FACTOR_REQUIRED: \"/help/two-factor-auth\",\n            AuthErrorType.ACCOUNT_VERIFICATION_FAILED: \"/help/account-verification\",\n            AuthErrorType.PASSWORD_RESET_FAILED: \"/help/password-reset\",\n        }\n    \n    def create_error(\n        self,\n        error_type: AuthErrorType,\n        message: Optional[str] = None,\n        details: Optional[Dict[str, Any]] = None,\n        status_code: Optional[int] = None,\n        severity: AuthErrorSeverity = AuthErrorSeverity.MEDIUM,\n        retry_after: Optional[int] = None,\n        request: Optional[Request] = None\n    ) -> AuthError:\n        \"\"\"Create a standardized authentication error.\"\"\"\n        \n        # Use default message if not provided\n        if not message:\n            message = self.user_messages.get(error_type, \"Authentication error occurred.\")\n        \n        # Use default status code if not provided\n        if not status_code:\n            status_code = self.error_status_mapping.get(error_type, status.HTTP_401_UNAUTHORIZED)\n        \n        # Add help URL if available\n        help_url = self.help_urls.get(error_type)\n        \n        # Create error\n        error = AuthError(\n            error_type=error_type,\n            message=message,\n            details=details,\n            status_code=status_code,\n            severity=severity,\n            retry_after=retry_after,\n            help_url=help_url\n        )\n        \n        # Log error\n        self._log_error(error, request)\n        \n        # Track error for monitoring\n        self._track_error(error)\n        \n        return error\n    \n    def handle_error(\n        self,\n        error: Exception,\n        request: Optional[Request] = None,\n        default_error_type: AuthErrorType = AuthErrorType.INTERNAL_ERROR\n    ) -> AuthError:\n        \"\"\"Handle any exception and convert to AuthError.\"\"\"\n        \n        if isinstance(error, AuthError):\n            return error\n        \n        if isinstance(error, HTTPException):\n            # Convert HTTPException to AuthError\n            error_type = self._map_http_status_to_error_type(error.status_code)\n            return self.create_error(\n                error_type=error_type,\n                message=str(error.detail),\n                status_code=error.status_code,\n                request=request\n            )\n        \n        # Handle unexpected errors\n        logger.error(f\"Unexpected authentication error: {error}\", exc_info=True)\n        \n        return self.create_error(\n            error_type=default_error_type,\n            message=\"An unexpected error occurred. Please try again later.\",\n            details={\"original_error\": str(error)},\n            severity=AuthErrorSeverity.HIGH,\n            request=request\n        )\n    \n    def create_response(self, error: AuthError, request_id: Optional[str] = None) -> JSONResponse:\n        \"\"\"Create a standardized error response.\"\"\"\n        \n        error_response = AuthErrorResponse(\n            error_id=error.error_id,\n            error_type=error.error_type,\n            error_code=f\"AUTH_{error.status_code}_{error.error_type.value.upper()}\",\n            message=error.message,\n            details=error.details if error.details else None,\n            timestamp=error.timestamp,\n            request_id=request_id,\n            retry_after=error.retry_after,\n            help_url=error.help_url\n        )\n        \n        headers = {}\n        \n        # Add WWW-Authenticate header for 401 errors\n        if error.status_code == status.HTTP_401_UNAUTHORIZED:\n            headers[\"WWW-Authenticate\"] = \"Bearer\"\n        \n        # Add Retry-After header for rate limiting\n        if error.retry_after:\n            headers[\"Retry-After\"] = str(error.retry_after)\n        \n        return JSONResponse(\n            status_code=error.status_code,\n            content=error_response.dict(exclude_none=True),\n            headers=headers\n        )\n    \n    def _log_error(self, error: AuthError, request: Optional[Request] = None) -> None:\n        \"\"\"Log authentication error with appropriate level.\"\"\"\n        \n        log_data = {\n            \"error_id\": error.error_id,\n            \"error_type\": error.error_type,\n            \"message\": error.message,\n            \"severity\": error.severity,\n            \"status_code\": error.status_code,\n        }\n        \n        if request:\n            log_data.update({\n                \"method\": request.method,\n                \"path\": request.url.path,\n                \"client_ip\": getattr(request.client, 'host', 'unknown'),\n                \"user_agent\": request.headers.get('user-agent', 'unknown'),\n            })\n        \n        if error.details:\n            log_data[\"details\"] = error.details\n        \n        # Log with appropriate level based on severity\n        if error.severity == AuthErrorSeverity.CRITICAL:\n            logger.critical(f\"Critical auth error: {log_data}\")\n        elif error.severity == AuthErrorSeverity.HIGH:\n            logger.error(f\"High severity auth error: {log_data}\")\n        elif error.severity == AuthErrorSeverity.MEDIUM:\n            logger.warning(f\"Medium severity auth error: {log_data}\")\n        else:\n            logger.info(f\"Low severity auth error: {log_data}\")\n    \n    def _track_error(self, error: AuthError) -> None:\n        \"\"\"Track error for monitoring and analytics.\"\"\"\n        \n        # Count errors by type\n        error_key = error.error_type.value\n        self.error_counts[error_key] = self.error_counts.get(error_key, 0) + 1\n        \n        # Add to history\n        error_record = {\n            \"error_id\": error.error_id,\n            \"error_type\": error.error_type,\n            \"severity\": error.severity,\n            \"timestamp\": error.timestamp,\n            \"status_code\": error.status_code,\n        }\n        \n        self.error_history.append(error_record)\n        \n        # Keep history size manageable\n        if len(self.error_history) > self.max_history:\n            self.error_history = self.error_history[-self.max_history:]\n    \n    def _map_http_status_to_error_type(self, status_code: int) -> AuthErrorType:\n        \"\"\"Map HTTP status code to authentication error type.\"\"\"\n        \n        mapping = {\n            401: AuthErrorType.TOKEN_INVALID,\n            403: AuthErrorType.PERMISSION_DENIED,\n            423: AuthErrorType.USER_LOCKED,\n            429: AuthErrorType.RATE_LIMIT_EXCEEDED,\n            500: AuthErrorType.INTERNAL_ERROR,\n        }\n        \n        return mapping.get(status_code, AuthErrorType.INTERNAL_ERROR)\n    \n    def get_error_statistics(self) -> Dict[str, Any]:\n        \"\"\"Get error statistics for monitoring.\"\"\"\n        \n        total_errors = sum(self.error_counts.values())\n        recent_errors = [e for e in self.error_history if time.time() - e[\"timestamp\"] < 3600]  # Last hour\n        \n        return {\n            \"total_errors\": total_errors,\n            \"error_counts\": self.error_counts.copy(),\n            \"recent_errors_count\": len(recent_errors),\n            \"error_rate_per_hour\": len(recent_errors),\n            \"most_common_errors\": sorted(\n                self.error_counts.items(),\n                key=lambda x: x[1],\n                reverse=True\n            )[:5],\n        }\n    \n    def clear_statistics(self) -> None:\n        \"\"\"Clear error statistics (for testing or maintenance).\"\"\"\n        self.error_counts.clear()\n        self.error_history.clear()\n\n\n# Global error handler instance\nauth_error_handler = AuthErrorHandler()\n\n\n# Convenience functions for common errors\ndef invalid_credentials_error(details: Optional[Dict[str, Any]] = None) -> AuthError:\n    \"\"\"Create invalid credentials error.\"\"\"\n    return auth_error_handler.create_error(\n        AuthErrorType.INVALID_CREDENTIALS,\n        details=details,\n        severity=AuthErrorSeverity.MEDIUM\n    )\n\n\ndef token_expired_error(details: Optional[Dict[str, Any]] = None) -> AuthError:\n    \"\"\"Create token expired error.\"\"\"\n    return auth_error_handler.create_error(\n        AuthErrorType.TOKEN_EXPIRED,\n        details=details,\n        severity=AuthErrorSeverity.LOW\n    )\n\n\ndef permission_denied_error(resource: str, details: Optional[Dict[str, Any]] = None) -> AuthError:\n    \"\"\"Create permission denied error.\"\"\"\n    return auth_error_handler.create_error(\n        AuthErrorType.PERMISSION_DENIED,\n        message=f\"You don't have permission to access {resource}.\",\n        details=details,\n        severity=AuthErrorSeverity.MEDIUM\n    )\n\n\ndef rate_limit_exceeded_error(retry_after: int = 60, details: Optional[Dict[str, Any]] = None) -> AuthError:\n    \"\"\"Create rate limit exceeded error.\"\"\"\n    return auth_error_handler.create_error(\n        AuthErrorType.RATE_LIMIT_EXCEEDED,\n        details=details,\n        retry_after=retry_after,\n        severity=AuthErrorSeverity.HIGH\n    )\n\n\ndef user_locked_error(details: Optional[Dict[str, Any]] = None) -> AuthError:\n    \"\"\"Create user locked error.\"\"\"\n    return auth_error_handler.create_error(\n        AuthErrorType.USER_LOCKED,\n        details=details,\n        severity=AuthErrorSeverity.HIGH\n    )\n\n\ndef password_weak_error(requirements: List[str], details: Optional[Dict[str, Any]] = None) -> AuthError:\n    \"\"\"Create password weak error.\"\"\"\n    message = \"Password does not meet requirements: \" + \", \".join(requirements)\n    return auth_error_handler.create_error(\n        AuthErrorType.PASSWORD_WEAK,\n        message=message,\n        details=details or {\"requirements\": requirements},\n        severity=AuthErrorSeverity.LOW\n    )\n\n\ndef security_violation_error(violation_type: str, details: Optional[Dict[str, Any]] = None) -> AuthError:\n    \"\"\"Create security violation error.\"\"\"\n    return auth_error_handler.create_error(\n        AuthErrorType.SECURITY_VIOLATION,\n        message=f\"Security violation detected: {violation_type}\",\n        details=details,\n        severity=AuthErrorSeverity.CRITICAL\n    )\n\n\n# Error handler decorator\ndef handle_auth_errors(func):\n    \"\"\"Decorator to handle authentication errors in endpoints.\"\"\"\n    \n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            error = auth_error_handler.handle_error(e)\n            raise HTTPException(\n                status_code=error.status_code,\n                detail=error.message\n            )\n    \n    return wrapper\n\n\n# Async error handler decorator\ndef handle_auth_errors_async(func):\n    \"\"\"Async decorator to handle authentication errors in endpoints.\"\"\"\n    \n    async def wrapper(*args, **kwargs):\n        try:\n            return await func(*args, **kwargs)\n        except Exception as e:\n            error = auth_error_handler.handle_error(e)\n            raise HTTPException(\n                status_code=error.status_code,\n                detail=error.message\n            )\n    \n    return wrapper\n"