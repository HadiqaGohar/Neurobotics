"""
Enhanced authentication middleware with comprehensive security features.
"""

import logging
import time
from typing import Callable, Optional, Set, Dict, Any
from fastapi import Request, HTTPException, status
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware
from src.auth.better_auth import AuthService
from src.security.security_utils import SecurityValidator
import jwt
import hashlib

logger = logging.getLogger(__name__)


class EnhancedAuthMiddleware(BaseHTTPMiddleware):
    \"\"\"Enhanced authentication middleware with security features.\"\"\"\n    \n    def __init__(self, app, config: Optional[Dict[str, Any]] = None):\n        super().__init__(app)\n        self.config = config or {}\n        \n        # Protected endpoints that require authentication\n        self.protected_endpoints: Set[str] = {\n            '/auth/me',\n            '/auth/logout',\n            '/api/chat',\n            '/api/upload',\n            '/api/personalization',\n        }\n        \n        # Public endpoints that don't require authentication\n        self.public_endpoints: Set[str] = {\n            '/auth/login',\n            '/auth/signup',\n            '/auth/refresh',\n            '/auth/forgot-password',\n            '/auth/reset-password',\n            '/health',\n            '/docs',\n            '/openapi.json',\n        }\n        \n        # Session tracking for security\n        self.active_sessions: Dict[str, Dict[str, Any]] = {}\n        \n        # Security configuration\n        self.enable_session_tracking = self.config.get('enable_session_tracking', True)\n        self.enable_token_blacklist = self.config.get('enable_token_blacklist', True)\n        self.max_sessions_per_user = self.config.get('max_sessions_per_user', 5)\n        \n        # Token blacklist for revoked tokens\n        self.blacklisted_tokens: Set[str] = set()\n    \n    async def dispatch(self, request: Request, call_next: Callable):\n        path = request.url.path\n        method = request.method\n        \n        try:\n            # Skip authentication for public endpoints\n            if self._is_public_endpoint(path):\n                return await call_next(request)\n            \n            # Check if endpoint requires authentication\n            if self._requires_authentication(path):\n                auth_result = await self._authenticate_request(request)\n                \n                if not auth_result['authenticated']:\n                    return self._create_auth_error_response(\n                        auth_result['status_code'],\n                        auth_result['message']\n                    )\n                \n                # Add user info to request state\n                request.state.user = auth_result['user']\n                request.state.session_id = auth_result.get('session_id')\n                \n                # Track session activity\n                if self.enable_session_tracking:\n                    self._track_session_activity(auth_result)\n            \n            # Process the request\n            response = await call_next(request)\n            \n            # Log successful authenticated request\n            if hasattr(request.state, 'user'):\n                logger.info(\n                    f\"Authenticated request - {method} {path} - \"\n                    f\"User: {request.state.user.email} - \"\n                    f\"Status: {response.status_code}\"\n                )\n            \n            return response\n            \n        except HTTPException as e:\n            logger.warning(\n                f\"Authentication error - {method} {path} - \"\n                f\"Status: {e.status_code} - Detail: {e.detail}\"\n            )\n            raise e\n            \n        except Exception as e:\n            logger.error(\n                f\"Unexpected error in auth middleware - {method} {path} - \"\n                f\"Error: {str(e)}\"\n            )\n            return self._create_auth_error_response(\n                status.HTTP_500_INTERNAL_SERVER_ERROR,\n                \"Authentication service error\"\n            )\n    \n    def _is_public_endpoint(self, path: str) -> bool:\n        \"\"\"Check if endpoint is public (doesn't require authentication).\"\"\"\n        # Exact match\n        if path in self.public_endpoints:\n            return True\n        \n        # Pattern matching for dynamic routes\n        public_patterns = [\n            '/docs',\n            '/redoc',\n            '/openapi.json',\n            '/static/',\n            '/favicon.ico',\n        ]\n        \n        return any(path.startswith(pattern) for pattern in public_patterns)\n    \n    def _requires_authentication(self, path: str) -> bool:\n        \"\"\"Check if endpoint requires authentication.\"\"\"\n        # Exact match\n        if path in self.protected_endpoints:\n            return True\n        \n        # Pattern matching for protected routes\n        protected_patterns = [\n            '/api/',\n            '/admin/',\n            '/user/',\n        ]\n        \n        return any(path.startswith(pattern) for pattern in protected_patterns)\n    \n    async def _authenticate_request(self, request: Request) -> Dict[str, Any]:\n        \"\"\"Authenticate the request and return authentication result.\"\"\"\n        try:\n            # Extract token from Authorization header\n            auth_header = request.headers.get('Authorization')\n            if not auth_header:\n                return {\n                    'authenticated': False,\n                    'status_code': status.HTTP_401_UNAUTHORIZED,\n                    'message': 'Missing authorization header'\n                }\n            \n            # Parse Bearer token\n            try:\n                scheme, token = auth_header.split(' ', 1)\n                if scheme.lower() != 'bearer':\n                    return {\n                        'authenticated': False,\n                        'status_code': status.HTTP_401_UNAUTHORIZED,\n                        'message': 'Invalid authorization scheme'\n                    }\n            except ValueError:\n                return {\n                    'authenticated': False,\n                    'status_code': status.HTTP_401_UNAUTHORIZED,\n                    'message': 'Invalid authorization header format'\n                }\n            \n            # Check if token is blacklisted\n            if self.enable_token_blacklist and self._is_token_blacklisted(token):\n                return {\n                    'authenticated': False,\n                    'status_code': status.HTTP_401_UNAUTHORIZED,\n                    'message': 'Token has been revoked'\n                }\n            \n            # Verify token and get user\n            try:\n                payload = AuthService.verify_token(token, 'access')\n                user_id = payload.get('sub')\n                \n                if not user_id:\n                    return {\n                        'authenticated': False,\n                        'status_code': status.HTTP_401_UNAUTHORIZED,\n                        'message': 'Invalid token payload'\n                    }\n                \n                # Get user from database\n                from src.database.database import get_db\n                from src.database.models import User\n                \n                db = next(get_db())\n                user = db.query(User).filter(User.id == user_id).first()\n                \n                if not user:\n                    return {\n                        'authenticated': False,\n                        'status_code': status.HTTP_401_UNAUTHORIZED,\n                        'message': 'User not found'\n                    }\n                \n                if not user.is_active:\n                    return {\n                        'authenticated': False,\n                        'status_code': status.HTTP_401_UNAUTHORIZED,\n                        'message': 'User account is disabled'\n                    }\n                \n                # Generate session ID for tracking\n                session_id = self._generate_session_id(user_id, token)\n                \n                return {\n                    'authenticated': True,\n                    'user': user,\n                    'session_id': session_id,\n                    'token_payload': payload\n                }\n                \n            except jwt.ExpiredSignatureError:\n                return {\n                    'authenticated': False,\n                    'status_code': status.HTTP_401_UNAUTHORIZED,\n                    'message': 'Token has expired'\n                }\n            except jwt.InvalidTokenError:\n                return {\n                    'authenticated': False,\n                    'status_code': status.HTTP_401_UNAUTHORIZED,\n                    'message': 'Invalid token'\n                }\n            \n        except Exception as e:\n            logger.error(f\"Authentication error: {e}\")\n            return {\n                'authenticated': False,\n                'status_code': status.HTTP_500_INTERNAL_SERVER_ERROR,\n                'message': 'Authentication service error'\n            }\n    \n    def _generate_session_id(self, user_id: str, token: str) -> str:\n        \"\"\"Generate a unique session ID for tracking.\"\"\"\n        session_data = f\"{user_id}:{token[:20]}:{time.time()}\"\n        return hashlib.sha256(session_data.encode()).hexdigest()[:16]\n    \n    def _track_session_activity(self, auth_result: Dict[str, Any]) -> None:\n        \"\"\"Track session activity for security monitoring.\"\"\"\n        try:\n            session_id = auth_result['session_id']\n            user = auth_result['user']\n            \n            # Update session info\n            self.active_sessions[session_id] = {\n                'user_id': user.id,\n                'user_email': user.email,\n                'last_activity': time.time(),\n                'created_at': self.active_sessions.get(session_id, {}).get('created_at', time.time()),\n                'request_count': self.active_sessions.get(session_id, {}).get('request_count', 0) + 1\n            }\n            \n            # Clean up old sessions\n            self._cleanup_old_sessions()\n            \n            # Check for too many sessions per user\n            user_sessions = [\n                sid for sid, info in self.active_sessions.items()\n                if info['user_id'] == user.id\n            ]\n            \n            if len(user_sessions) > self.max_sessions_per_user:\n                # Remove oldest session\n                oldest_session = min(\n                    user_sessions,\n                    key=lambda sid: self.active_sessions[sid]['created_at']\n                )\n                del self.active_sessions[oldest_session]\n                logger.warning(\n                    f\"Removed oldest session for user {user.email} - \"\n                    f\"Max sessions ({self.max_sessions_per_user}) exceeded\"\n                )\n            \n        except Exception as e:\n            logger.error(f\"Error tracking session activity: {e}\")\n    \n    def _cleanup_old_sessions(self) -> None:\n        \"\"\"Clean up old inactive sessions.\"\"\"\n        try:\n            current_time = time.time()\n            session_timeout = 3600  # 1 hour\n            \n            expired_sessions = [\n                sid for sid, info in self.active_sessions.items()\n                if current_time - info['last_activity'] > session_timeout\n            ]\n            \n            for session_id in expired_sessions:\n                del self.active_sessions[session_id]\n            \n            if expired_sessions:\n                logger.info(f\"Cleaned up {len(expired_sessions)} expired sessions\")\n                \n        except Exception as e:\n            logger.error(f\"Error cleaning up sessions: {e}\")\n    \n    def _is_token_blacklisted(self, token: str) -> bool:\n        \"\"\"Check if token is in the blacklist.\"\"\"\n        # Create a hash of the token for storage efficiency\n        token_hash = hashlib.sha256(token.encode()).hexdigest()\n        return token_hash in self.blacklisted_tokens\n    \n    def blacklist_token(self, token: str) -> None:\n        \"\"\"Add token to blacklist.\"\"\"\n        token_hash = hashlib.sha256(token.encode()).hexdigest()\n        self.blacklisted_tokens.add(token_hash)\n        logger.info(f\"Token blacklisted: {token_hash[:16]}...\")\n    \n    def get_session_info(self, session_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get session information.\"\"\"\n        return self.active_sessions.get(session_id)\n    \n    def get_user_sessions(self, user_id: int) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Get all active sessions for a user.\"\"\"\n        return {\n            sid: info for sid, info in self.active_sessions.items()\n            if info['user_id'] == user_id\n        }\n    \n    def revoke_user_sessions(self, user_id: int) -> int:\n        \"\"\"Revoke all sessions for a user.\"\"\"\n        user_sessions = [\n            sid for sid, info in self.active_sessions.items()\n            if info['user_id'] == user_id\n        ]\n        \n        for session_id in user_sessions:\n            del self.active_sessions[session_id]\n        \n        logger.info(f\"Revoked {len(user_sessions)} sessions for user {user_id}\")\n        return len(user_sessions)\n    \n    def _create_auth_error_response(self, status_code: int, message: str) -> JSONResponse:\n        \"\"\"Create a standardized authentication error response.\"\"\"\n        return JSONResponse(\n            status_code=status_code,\n            content={\n                \"detail\": message,\n                \"error_code\": f\"AUTH_{status_code}\",\n                \"timestamp\": int(time.time())\n            },\n            headers={\"WWW-Authenticate\": \"Bearer\"}\n        )\n\n\nclass SessionSecurityMiddleware(BaseHTTPMiddleware):\n    \"\"\"Middleware for session security and monitoring.\"\"\"\n    \n    def __init__(self, app):\n        super().__init__(app)\n        self.suspicious_activities = []\n        self.max_suspicious_activities = 1000\n    \n    async def dispatch(self, request: Request, call_next: Callable):\n        start_time = time.time()\n        \n        # Process request\n        response = await call_next(request)\n        \n        # Monitor for suspicious activities\n        if hasattr(request.state, 'user'):\n            self._monitor_user_activity(request, response, start_time)\n        \n        return response\n    \n    def _monitor_user_activity(self, request: Request, response, start_time: float) -> None:\n        \"\"\"Monitor user activity for suspicious patterns.\"\"\"\n        try:\n            user = request.state.user\n            process_time = time.time() - start_time\n            \n            # Check for suspicious patterns\n            suspicious_indicators = []\n            \n            # Very fast requests might indicate automation\n            if process_time < 0.01:\n                suspicious_indicators.append('very_fast_request')\n            \n            # Multiple failed requests\n            if response.status_code >= 400:\n                suspicious_indicators.append(f'error_response_{response.status_code}')\n            \n            # Large response times might indicate resource abuse\n            if process_time > 10.0:\n                suspicious_indicators.append('slow_request')\n            \n            # Log suspicious activity\n            if suspicious_indicators:\n                activity = {\n                    'timestamp': time.time(),\n                    'user_id': user.id,\n                    'user_email': user.email,\n                    'path': request.url.path,\n                    'method': request.method,\n                    'indicators': suspicious_indicators,\n                    'process_time': process_time,\n                    'status_code': response.status_code\n                }\n                \n                self.suspicious_activities.append(activity)\n                \n                # Keep only recent activities\n                if len(self.suspicious_activities) > self.max_suspicious_activities:\n                    self.suspicious_activities = self.suspicious_activities[-self.max_suspicious_activities:]\n                \n                logger.warning(\n                    f\"Suspicious activity detected - User: {user.email} - \"\n                    f\"Path: {request.url.path} - Indicators: {suspicious_indicators}\"\n                )\n        \n        except Exception as e:\n            logger.error(f\"Error monitoring user activity: {e}\")\n    \n    def get_suspicious_activities(self, user_id: Optional[int] = None, limit: int = 100) -> list:\n        \"\"\"Get recent suspicious activities.\"\"\"\n        activities = self.suspicious_activities\n        \n        if user_id:\n            activities = [a for a in activities if a['user_id'] == user_id]\n        \n        return activities[-limit:]\n"