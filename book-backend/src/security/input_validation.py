"""
Comprehensive input validation and sanitization system.
"""

import re
import html
import json
import logging
from typing import Any, Dict, List, Optional, Union, Tuple
from pydantic import BaseModel, validator
from fastapi import HTTPException, status
import bleach
from urllib.parse import urlparse
import base64

logger = logging.getLogger(__name__)


class ValidationError(Exception):
    \"\"\"Custom validation error.\"\"\"\n    pass\n\n\nclass InputValidator:\n    \"\"\"Comprehensive input validation system.\"\"\"\n    \n    # Common dangerous patterns\n    XSS_PATTERNS = [\n        r'<script[^>]*>.*?</script>',\n        r'javascript:',\n        r'vbscript:',\n        r'on\\w+\\s*=',\n        r'<iframe[^>]*>.*?</iframe>',\n        r'<object[^>]*>.*?</object>',\n        r'<embed[^>]*>.*?</embed>',\n        r'<link[^>]*>',\n        r'<meta[^>]*>',\n        r'data:text/html',\n        r'<svg[^>]*>.*?</svg>',\n    ]\n    \n    SQL_INJECTION_PATTERNS = [\n        r'(\\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION)\\b)',\n        r'(\\b(OR|AND)\\s+\\d+\\s*=\\s*\\d+)',\n        r'(\\b(OR|AND)\\s+[\\'\"\\']?\\w+[\\'\"\\']?\\s*=\\s*[\\'\"\\']?\\w+[\\'\"\\']?)',\n        r'(--|#|/\\*|\\*/)',\n        r'(\\bxp_\\w+)',\n        r'(\\bsp_\\w+)',\n        r'(\\bunion\\s+select)',\n        r'(\\bselect\\s+.*\\bfrom)',\n        r'(\\binsert\\s+into)',\n        r'(\\bdelete\\s+from)',\n        r'(\\bdrop\\s+table)',\n    ]\n    \n    COMMAND_INJECTION_PATTERNS = [\n        r'[;&|`$(){}\\[\\]<>]',\n        r'\\b(cat|ls|pwd|whoami|id|uname|ps|netstat|ifconfig)\\b',\n        r'\\b(rm|mv|cp|chmod|chown|kill|killall)\\b',\n        r'\\b(wget|curl|nc|telnet|ssh|ftp)\\b',\n        r'\\b(python|perl|ruby|php|bash|sh|zsh|csh)\\b',\n    ]\n    \n    # Allowed HTML tags for rich text (if needed)\n    ALLOWED_HTML_TAGS = [\n        'p', 'br', 'strong', 'em', 'u', 'ol', 'ul', 'li',\n        'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote'\n    ]\n    \n    ALLOWED_HTML_ATTRIBUTES = {\n        '*': ['class'],\n        'a': ['href', 'title'],\n        'img': ['src', 'alt', 'width', 'height'],\n    }\n    \n    @classmethod\n    def sanitize_string(cls, text: str, max_length: int = 10000, allow_html: bool = False) -> str:\n        \"\"\"Sanitize string input with comprehensive protection.\"\"\"\n        if not isinstance(text, str):\n            text = str(text)\n        \n        if not text:\n            return \"\"\n        \n        # Truncate to max length\n        if len(text) > max_length:\n            text = text[:max_length]\n            logger.warning(f\"Input truncated to {max_length} characters\")\n        \n        # Remove null bytes and control characters\n        text = ''.join(char for char in text if ord(char) >= 32 or char in '\\t\\n\\r')\n        \n        if allow_html:\n            # Use bleach for safe HTML sanitization\n            text = bleach.clean(\n                text,\n                tags=cls.ALLOWED_HTML_TAGS,\n                attributes=cls.ALLOWED_HTML_ATTRIBUTES,\n                strip=True\n            )\n        else:\n            # HTML escape for plain text\n            text = html.escape(text)\n            \n            # Remove dangerous patterns\n            for pattern in cls.XSS_PATTERNS:\n                text = re.sub(pattern, '', text, flags=re.IGNORECASE)\n        \n        return text.strip()\n    \n    @classmethod\n    def validate_email(cls, email: str) -> Tuple[bool, str]:\n        \"\"\"Validate email address with comprehensive checks.\"\"\"\n        if not email:\n            return False, \"Email is required\"\n        \n        # Length check\n        if len(email) > 254:  # RFC 5321 limit\n            return False, \"Email too long\"\n        \n        # Basic format check\n        email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n        if not re.match(email_pattern, email):\n            return False, \"Invalid email format\"\n        \n        # Split local and domain parts\n        try:\n            local, domain = email.rsplit('@', 1)\n        except ValueError:\n            return False, \"Invalid email format\"\n        \n        # Local part checks\n        if len(local) > 64:  # RFC 5321 limit\n            return False, \"Email local part too long\"\n        \n        if local.startswith('.') or local.endswith('.'):\n            return False, \"Invalid email local part\"\n        \n        if '..' in local:\n            return False, \"Invalid email local part\"\n        \n        # Domain part checks\n        if len(domain) > 253:  # RFC 5321 limit\n            return False, \"Email domain too long\"\n        \n        # Check for suspicious patterns\n        suspicious_patterns = ['--', '__', '..', 'admin', 'root', 'test']\n        email_lower = email.lower()\n        \n        for pattern in suspicious_patterns:\n            if pattern in email_lower:\n                logger.warning(f\"Suspicious email pattern detected: {pattern}\")\n        \n        return True, \"Valid email\"\n    \n    @classmethod\n    def validate_password(cls, password: str) -> Tuple[bool, List[str]]:\n        \"\"\"Validate password strength with detailed feedback.\"\"\"\n        if not password:\n            return False, [\"Password is required\"]\n        \n        errors = []\n        \n        # Length check\n        if len(password) < 8:\n            errors.append(\"Password must be at least 8 characters long\")\n        \n        if len(password) > 128:\n            errors.append(\"Password must be less than 128 characters long\")\n        \n        # Character requirements\n        if not re.search(r'[a-z]', password):\n            errors.append(\"Password must contain at least one lowercase letter\")\n        \n        if not re.search(r'[A-Z]', password):\n            errors.append(\"Password must contain at least one uppercase letter\")\n        \n        if not re.search(r'\\d', password):\n            errors.append(\"Password must contain at least one digit\")\n        \n        if not re.search(r'[!@#$%^&*()_+\\-=\\[\\]{}|;:,.<>?]', password):\n            errors.append(\"Password must contain at least one special character\")\n        \n        # Common password checks\n        common_passwords = [\n            'password', '123456', 'password123', 'admin', 'qwerty',\n            'letmein', 'welcome', 'monkey', '1234567890'\n        ]\n        \n        if password.lower() in common_passwords:\n            errors.append(\"Password is too common\")\n        \n        # Sequential characters check\n        if re.search(r'(012|123|234|345|456|567|678|789|890)', password):\n            errors.append(\"Password should not contain sequential numbers\")\n        \n        if re.search(r'(abc|bcd|cde|def|efg|fgh|ghi|hij|ijk|jkl|klm|lmn|mno|nop|opq|pqr|qrs|rst|stu|tuv|uvw|vwx|wxy|xyz)', password.lower()):\n            errors.append(\"Password should not contain sequential letters\")\n        \n        return len(errors) == 0, errors\n    \n    @classmethod\n    def validate_username(cls, username: str) -> Tuple[bool, str]:\n        \"\"\"Validate username format.\"\"\"\n        if not username:\n            return False, \"Username is required\"\n        \n        # Length check\n        if len(username) < 3:\n            return False, \"Username must be at least 3 characters long\"\n        \n        if len(username) > 50:\n            return False, \"Username must be less than 50 characters long\"\n        \n        # Character check\n        if not re.match(r'^[a-zA-Z0-9_.-]+$', username):\n            return False, \"Username can only contain letters, numbers, dots, hyphens, and underscores\"\n        \n        # Reserved usernames\n        reserved = [\n            'admin', 'administrator', 'root', 'system', 'user',\n            'test', 'guest', 'anonymous', 'null', 'undefined'\n        ]\n        \n        if username.lower() in reserved:\n            return False, \"Username is reserved\"\n        \n        return True, \"Valid username\"\n    \n    @classmethod\n    def validate_url(cls, url: str) -> Tuple[bool, str]:\n        \"\"\"Validate URL format and security.\"\"\"\n        if not url:\n            return False, \"URL is required\"\n        \n        try:\n            parsed = urlparse(url)\n        except Exception:\n            return False, \"Invalid URL format\"\n        \n        # Scheme check\n        if parsed.scheme not in ['http', 'https']:\n            return False, \"URL must use HTTP or HTTPS\"\n        \n        # Domain check\n        if not parsed.netloc:\n            return False, \"URL must have a domain\"\n        \n        # Check for suspicious patterns\n        suspicious_patterns = [\n            'localhost', '127.0.0.1', '0.0.0.0', '::1',\n            '192.168.', '10.', '172.16.', '172.17.', '172.18.',\n            '172.19.', '172.20.', '172.21.', '172.22.', '172.23.',\n            '172.24.', '172.25.', '172.26.', '172.27.', '172.28.',\n            '172.29.', '172.30.', '172.31.'\n        ]\n        \n        for pattern in suspicious_patterns:\n            if pattern in url.lower():\n                return False, f\"URL contains suspicious pattern: {pattern}\"\n        \n        return True, \"Valid URL\"\n    \n    @classmethod\n    def validate_json(cls, json_str: str, max_size: int = 1024 * 1024) -> Tuple[bool, Union[Dict, str]]:\n        \"\"\"Validate and parse JSON input.\"\"\"\n        if not json_str:\n            return False, \"JSON is required\"\n        \n        # Size check\n        if len(json_str) > max_size:\n            return False, f\"JSON too large (max {max_size} bytes)\"\n        \n        try:\n            data = json.loads(json_str)\n            return True, data\n        except json.JSONDecodeError as e:\n            return False, f\"Invalid JSON: {str(e)}\"\n    \n    @classmethod\n    def validate_file_upload(cls, filename: str, content: bytes, allowed_extensions: Optional[List[str]] = None) -> Tuple[bool, str]:\n        \"\"\"Validate file upload with comprehensive security checks.\"\"\"\n        if not filename:\n            return False, \"Filename is required\"\n        \n        # Sanitize filename\n        filename = cls.sanitize_filename(filename)\n        \n        # Extension check\n        if allowed_extensions:\n            file_ext = filename.lower().split('.')[-1] if '.' in filename else ''\n            if file_ext not in [ext.lower().lstrip('.') for ext in allowed_extensions]:\n                return False, f\"File type .{file_ext} not allowed\"\n        \n        # Size check (10MB default limit)\n        max_size = 10 * 1024 * 1024\n        if len(content) > max_size:\n            return False, f\"File too large (max {max_size // (1024*1024)}MB)\"\n        \n        # Content validation\n        try:\n            # Check first 1KB for malicious patterns\n            content_sample = content[:1024].decode('utf-8', errors='ignore').lower()\n            \n            malicious_patterns = [\n                '<script', 'javascript:', 'vbscript:', 'data:text/html',\n                '<?php', '<%', '<jsp:', '#!/bin/', '#!/usr/bin/'\n            ]\n            \n            for pattern in malicious_patterns:\n                if pattern in content_sample:\n                    return False, f\"Potentially malicious content detected: {pattern}\"\n        \n        except Exception:\n            # If we can't decode, it might be binary - that's okay\n            pass\n        \n        return True, \"Valid file\"\n    \n    @classmethod\n    def sanitize_filename(cls, filename: str) -> str:\n        \"\"\"Sanitize filename for safe storage.\"\"\"\n        if not filename:\n            return \"unnamed_file\"\n        \n        # Remove path separators and dangerous characters\n        filename = re.sub(r'[^\\w\\-_\\.]', '_', filename)\n        \n        # Remove leading dots and spaces\n        filename = filename.lstrip('. ')\n        \n        # Limit length\n        if len(filename) > 100:\n            name, ext = filename.rsplit('.', 1) if '.' in filename else (filename, '')\n            filename = name[:90] + ('.' + ext if ext else '')\n        \n        # Ensure it's not empty\n        if not filename or filename == '.':\n            filename = \"unnamed_file\"\n        \n        return filename\n    \n    @classmethod\n    def validate_sql_query_safety(cls, query: str) -> Tuple[bool, str]:\n        \"\"\"Check if query contains potential SQL injection.\"\"\"\n        if not query:\n            return True, \"Empty query\"\n        \n        query_lower = query.lower()\n        \n        for pattern in cls.SQL_INJECTION_PATTERNS:\n            if re.search(pattern, query_lower, re.IGNORECASE):\n                return False, f\"Potential SQL injection detected: {pattern}\"\n        \n        return True, \"Query appears safe\"\n    \n    @classmethod\n    def validate_command_safety(cls, command: str) -> Tuple[bool, str]:\n        \"\"\"Check if command contains potential command injection.\"\"\"\n        if not command:\n            return True, \"Empty command\"\n        \n        for pattern in cls.COMMAND_INJECTION_PATTERNS:\n            if re.search(pattern, command, re.IGNORECASE):\n                return False, f\"Potential command injection detected: {pattern}\"\n        \n        return True, \"Command appears safe\"\n    \n    @classmethod\n    def validate_base64(cls, data: str, max_decoded_size: int = 10 * 1024 * 1024) -> Tuple[bool, str]:\n        \"\"\"Validate base64 encoded data.\"\"\"\n        if not data:\n            return False, \"Base64 data is required\"\n        \n        try:\n            # Remove whitespace and validate format\n            data = re.sub(r'\\s+', '', data)\n            \n            if not re.match(r'^[A-Za-z0-9+/]*={0,2}$', data):\n                return False, \"Invalid base64 format\"\n            \n            # Decode and check size\n            decoded = base64.b64decode(data)\n            \n            if len(decoded) > max_decoded_size:\n                return False, f\"Decoded data too large (max {max_decoded_size} bytes)\"\n            \n            return True, \"Valid base64 data\"\n            \n        except Exception as e:\n            return False, f\"Base64 decode error: {str(e)}\"\n\n\nclass SecureRequestValidator(BaseModel):\n    \"\"\"Pydantic model for secure request validation.\"\"\"\n    \n    @validator('*', pre=True)\n    def sanitize_strings(cls, v):\n        \"\"\"Automatically sanitize string inputs.\"\"\"\n        if isinstance(v, str):\n            return InputValidator.sanitize_string(v)\n        return v\n\n\ndef validate_request_data(data: Dict[str, Any], validation_rules: Dict[str, Dict[str, Any]]) -> Tuple[bool, Dict[str, Any]]:\n    \"\"\"Validate request data against custom rules.\"\"\"\n    errors = {}\n    \n    for field, rules in validation_rules.items():\n        value = data.get(field)\n        \n        # Required field check\n        if rules.get('required', False) and not value:\n            errors[field] = \"Field is required\"\n            continue\n        \n        if value is None:\n            continue\n        \n        # Type validation\n        expected_type = rules.get('type')\n        if expected_type and not isinstance(value, expected_type):\n            errors[field] = f\"Expected {expected_type.__name__}, got {type(value).__name__}\"\n            continue\n        \n        # String validations\n        if isinstance(value, str):\n            min_length = rules.get('min_length')\n            max_length = rules.get('max_length', 10000)\n            \n            if min_length and len(value) < min_length:\n                errors[field] = f\"Minimum length is {min_length}\"\n                continue\n            \n            if len(value) > max_length:\n                errors[field] = f\"Maximum length is {max_length}\"\n                continue\n            \n            # Pattern validation\n            pattern = rules.get('pattern')\n            if pattern and not re.match(pattern, value):\n                errors[field] = \"Invalid format\"\n                continue\n            \n            # Custom validation functions\n            validator_func = rules.get('validator')\n            if validator_func:\n                is_valid, message = validator_func(value)\n                if not is_valid:\n                    errors[field] = message\n                    continue\n        \n        # Numeric validations\n        if isinstance(value, (int, float)):\n            min_value = rules.get('min_value')\n            max_value = rules.get('max_value')\n            \n            if min_value is not None and value < min_value:\n                errors[field] = f\"Minimum value is {min_value}\"\n                continue\n            \n            if max_value is not None and value > max_value:\n                errors[field] = f\"Maximum value is {max_value}\"\n                continue\n    \n    return len(errors) == 0, errors\n\n\ndef create_validation_error(message: str, field: Optional[str] = None) -> HTTPException:\n    \"\"\"Create a standardized validation error response.\"\"\"\n    detail = {\"message\": message}\n    if field:\n        detail[\"field\"] = field\n    \n    return HTTPException(\n        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n        detail=detail\n    )\n"