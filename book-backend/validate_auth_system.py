#!/usr/bin/env python3\n\"\"\"\nAuthentication system validation and deployment readiness checker.\n\"\"\"\n\nimport os\nimport sys\nimport json\nimport time\nfrom typing import Dict, List, Any, Tuple\nfrom pathlib import Path\n\n# Add src to path\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))\n\n\nclass AuthSystemValidator:\n    \"\"\"Comprehensive authentication system validator.\"\"\"\n    \n    def __init__(self):\n        self.validation_results = {}\n        self.warnings = []\n        self.errors = []\n        self.recommendations = []\n    \n    def validate_system(self) -> Dict[str, Any]:\n        \"\"\"Run comprehensive system validation.\"\"\"\n        print(\"üîê Authentication System Validation\")\n        print(\"=\" * 50)\n        \n        # Run all validation checks\n        self._validate_security_configuration()\n        self._validate_file_structure()\n        self._validate_dependencies()\n        self._validate_environment_variables()\n        self._validate_security_features()\n        self._validate_error_handling()\n        self._validate_monitoring_system()\n        self._validate_documentation()\n        self._check_deployment_readiness()\n        \n        # Generate final report\n        return self._generate_validation_report()\n    \n    def _validate_security_configuration(self) -> None:\n        \"\"\"Validate security configuration.\"\"\"\n        print(\"\\nüîí Validating Security Configuration...\")\n        \n        try:\n            from src.security.security_config import get_security_manager\n            \n            security_manager = get_security_manager()\n            config = security_manager.config\n            warnings = security_manager.warnings\n            \n            # Check security level\n            if config.security_level.value in ['low', 'medium']:\n                self.warnings.append(\"Consider using HIGH or MAXIMUM security level for production\")\n            \n            # Check critical settings\n            if config.jwt_secret_key == \"change-this-in-production\":\n                self.errors.append(\"JWT secret key must be changed from default\")\n            \n            if len(config.jwt_secret_key) < 32:\n                self.errors.append(\"JWT secret key should be at least 32 characters long\")\n            \n            if not config.enable_rate_limiting:\n                self.warnings.append(\"Rate limiting should be enabled for production\")\n            \n            if not config.enable_security_headers:\n                self.warnings.append(\"Security headers should be enabled\")\n            \n            if not config.enable_csrf_protection:\n                self.warnings.append(\"CSRF protection should be enabled\")\n            \n            # Add configuration warnings\n            self.warnings.extend(warnings)\n            \n            self.validation_results['security_config'] = {\n                'status': 'passed' if not self.errors else 'failed',\n                'security_level': config.security_level.value,\n                'features_enabled': {\n                    'rate_limiting': config.enable_rate_limiting,\n                    'csrf_protection': config.enable_csrf_protection,\n                    'security_headers': config.enable_security_headers,\n                    'input_sanitization': config.enable_input_sanitization,\n                },\n                'warnings': len(warnings)\n            }\n            \n            print(f\"  ‚úÖ Security level: {config.security_level.value}\")\n            print(f\"  ‚úÖ Features enabled: {sum(self.validation_results['security_config']['features_enabled'].values())}/4\")\n            \n        except Exception as e:\n            self.errors.append(f\"Security configuration validation failed: {e}\")\n            print(f\"  ‚ùå Security configuration validation failed: {e}\")\n    \n    def _validate_file_structure(self) -> None:\n        \"\"\"Validate required file structure.\"\"\"\n        print(\"\\nüìÅ Validating File Structure...\")\n        \n        required_files = [\n            'src/auth/routes.py',\n            'src/auth/better_auth.py',\n            'src/auth/error_handling.py',\n            'src/auth/error_monitoring.py',\n            'src/auth/fallback_mechanisms.py',\n            'src/security/security_config.py',\n            'src/security/security_utils.py',\n            'src/security/input_validation.py',\n            'src/security/security_integration.py',\n            'src/middleware/security_middleware.py',\n            'src/middleware/auth_middleware.py',\n            'src/middleware/error_handler.py',\n        ]\n        \n        missing_files = []\n        present_files = []\n        \n        for file_path in required_files:\n            if os.path.exists(file_path):\n                present_files.append(file_path)\n                print(f\"  ‚úÖ {file_path}\")\n            else:\n                missing_files.append(file_path)\n                print(f\"  ‚ùå {file_path} - MISSING\")\n        \n        if missing_files:\n            self.errors.extend([f\"Missing required file: {f}\" for f in missing_files])\n        \n        self.validation_results['file_structure'] = {\n            'status': 'passed' if not missing_files else 'failed',\n            'present_files': len(present_files),\n            'missing_files': len(missing_files),\n            'total_required': len(required_files)\n        }\n    \n    def _validate_dependencies(self) -> None:\n        \"\"\"Validate required dependencies.\"\"\"\n        print(\"\\nüì¶ Validating Dependencies...\")\n        \n        required_packages = [\n            'fastapi',\n            'pydantic',\n            'sqlalchemy',\n            'bcrypt',\n            'python-jose',\n            'passlib',\n            'bleach',\n        ]\n        \n        missing_packages = []\n        present_packages = []\n        \n        for package in required_packages:\n            try:\n                __import__(package.replace('-', '_'))\n                present_packages.append(package)\n                print(f\"  ‚úÖ {package}\")\n            except ImportError:\n                missing_packages.append(package)\n                print(f\"  ‚ùå {package} - NOT INSTALLED\")\n        \n        if missing_packages:\n            self.errors.extend([f\"Missing required package: {p}\" for p in missing_packages])\n        \n        self.validation_results['dependencies'] = {\n            'status': 'passed' if not missing_packages else 'failed',\n            'present_packages': len(present_packages),\n            'missing_packages': len(missing_packages),\n            'total_required': len(required_packages)\n        }\n    \n    def _validate_environment_variables(self) -> None:\n        \"\"\"Validate environment variables.\"\"\"\n        print(\"\\nüåç Validating Environment Variables...\")\n        \n        required_vars = {\n            'JWT_SECRET_KEY': 'JWT secret key for token signing',\n            'DATABASE_URL': 'Database connection URL',\n        }\n        \n        optional_vars = {\n            'SECURITY_ENVIRONMENT': 'Environment (development/production)',\n            'SECURITY_SECURITY_LEVEL': 'Security level (low/medium/high/maximum)',\n            'SECURITY_ENABLE_RATE_LIMITING': 'Enable rate limiting',\n            'SECURITY_ENABLE_CSRF_PROTECTION': 'Enable CSRF protection',\n        }\n        \n        missing_required = []\n        missing_optional = []\n        \n        for var, description in required_vars.items():\n            if os.getenv(var):\n                print(f\"  ‚úÖ {var} - {description}\")\n            else:\n                missing_required.append(var)\n                print(f\"  ‚ùå {var} - MISSING - {description}\")\n        \n        for var, description in optional_vars.items():\n            if os.getenv(var):\n                print(f\"  ‚úÖ {var} - {description}\")\n            else:\n                missing_optional.append(var)\n                print(f\"  ‚ö†Ô∏è  {var} - OPTIONAL - {description}\")\n        \n        if missing_required:\n            self.errors.extend([f\"Missing required environment variable: {v}\" for v in missing_required])\n        \n        if missing_optional:\n            self.recommendations.extend([f\"Consider setting optional environment variable: {v}\" for v in missing_optional])\n        \n        self.validation_results['environment'] = {\n            'status': 'passed' if not missing_required else 'failed',\n            'required_present': len(required_vars) - len(missing_required),\n            'optional_present': len(optional_vars) - len(missing_optional),\n            'total_required': len(required_vars),\n            'total_optional': len(optional_vars)\n        }\n    \n    def _validate_security_features(self) -> None:\n        \"\"\"Validate security features.\"\"\"\n        print(\"\\nüõ°Ô∏è  Validating Security Features...\")\n        \n        try:\n            # Test input validation\n            from src.security.input_validation import InputValidator\n            \n            # Test XSS protection\n            xss_input = \"<script>alert('xss')</script>\"\n            sanitized = InputValidator.sanitize_string(xss_input)\n            xss_protected = \"<script>\" not in sanitized\n            \n            # Test SQL injection protection\n            sql_input = \"'; DROP TABLE users; --\"\n            sql_safe, _ = InputValidator.validate_sql_query_safety(sql_input)\n            sql_protected = not sql_safe\n            \n            # Test password validation\n            weak_password = \"password123\"\n            strong_password = \"StrongP@ssw0rd123!\"\n            weak_valid, _ = InputValidator.validate_password(weak_password)\n            strong_valid, _ = InputValidator.validate_password(strong_password)\n            password_validation = not weak_valid and strong_valid\n            \n            # Test email validation\n            invalid_email = \"invalid-email\"\n            valid_email = \"test@example.com\"\n            invalid_valid, _ = InputValidator.validate_email(invalid_email)\n            valid_valid, _ = InputValidator.validate_email(valid_email)\n            email_validation = not invalid_valid and valid_valid\n            \n            security_features = {\n                'xss_protection': xss_protected,\n                'sql_injection_protection': sql_protected,\n                'password_validation': password_validation,\n                'email_validation': email_validation,\n            }\n            \n            for feature, working in security_features.items():\n                status = \"‚úÖ\" if working else \"‚ùå\"\n                print(f\"  {status} {feature.replace('_', ' ').title()}\")\n                \n                if not working:\n                    self.errors.append(f\"Security feature not working: {feature}\")\n            \n            self.validation_results['security_features'] = {\n                'status': 'passed' if all(security_features.values()) else 'failed',\n                'features': security_features,\n                'working_features': sum(security_features.values()),\n                'total_features': len(security_features)\n            }\n            \n        except Exception as e:\n            self.errors.append(f\"Security features validation failed: {e}\")\n            print(f\"  ‚ùå Security features validation failed: {e}\")\n    \n    def _validate_error_handling(self) -> None:\n        \"\"\"Validate error handling system.\"\"\"\n        print(\"\\nüö® Validating Error Handling...\")\n        \n        try:\n            from src.auth.error_handling import (\n                auth_error_handler,\n                AuthErrorType,\n                invalid_credentials_error,\n                token_expired_error\n            )\n            \n            # Test error creation\n            error = auth_error_handler.create_error(\n                AuthErrorType.INVALID_CREDENTIALS,\n                \"Test error\"\n            )\n            \n            # Test convenience functions\n            cred_error = invalid_credentials_error()\n            token_error = token_expired_error()\n            \n            # Test error response creation\n            response = auth_error_handler.create_response(error)\n            \n            # Test error statistics\n            stats = auth_error_handler.get_error_statistics()\n            \n            error_handling_features = {\n                'error_creation': error is not None,\n                'convenience_functions': cred_error is not None and token_error is not None,\n                'response_creation': response is not None,\n                'statistics_tracking': isinstance(stats, dict) and 'total_errors' in stats,\n            }\n            \n            for feature, working in error_handling_features.items():\n                status = \"‚úÖ\" if working else \"‚ùå\"\n                print(f\"  {status} {feature.replace('_', ' ').title()}\")\n                \n                if not working:\n                    self.errors.append(f\"Error handling feature not working: {feature}\")\n            \n            self.validation_results['error_handling'] = {\n                'status': 'passed' if all(error_handling_features.values()) else 'failed',\n                'features': error_handling_features,\n                'working_features': sum(error_handling_features.values()),\n                'total_features': len(error_handling_features)\n            }\n            \n        except Exception as e:\n            self.errors.append(f\"Error handling validation failed: {e}\")\n            print(f\"  ‚ùå Error handling validation failed: {e}\")\n    \n    def _validate_monitoring_system(self) -> None:\n        \"\"\"Validate monitoring system.\"\"\"\n        print(\"\\nüìä Validating Monitoring System...\")\n        \n        try:\n            from src.auth.error_monitoring import (\n                security_monitor,\n                record_failed_login,\n                record_successful_login,\n                get_security_metrics\n            )\n            \n            # Test metrics recording\n            record_failed_login(\"test_user\", \"192.168.1.1\", \"Mozilla/5.0\")\n            record_successful_login(\"test_user\", \"192.168.1.1\", \"Mozilla/5.0\")\n            \n            # Test metrics retrieval\n            metrics = get_security_metrics()\n            \n            # Test dashboard data\n            dashboard = security_monitor.get_security_dashboard()\n            \n            monitoring_features = {\n                'metrics_recording': True,  # If we got here, it worked\n                'metrics_retrieval': isinstance(metrics, dict),\n                'dashboard_data': isinstance(dashboard, dict) and 'metrics' in dashboard,\n                'alert_system': hasattr(security_monitor, 'alert_manager'),\n            }\n            \n            for feature, working in monitoring_features.items():\n                status = \"‚úÖ\" if working else \"‚ùå\"\n                print(f\"  {status} {feature.replace('_', ' ').title()}\")\n                \n                if not working:\n                    self.errors.append(f\"Monitoring feature not working: {feature}\")\n            \n            self.validation_results['monitoring'] = {\n                'status': 'passed' if all(monitoring_features.values()) else 'failed',\n                'features': monitoring_features,\n                'working_features': sum(monitoring_features.values()),\n                'total_features': len(monitoring_features)\n            }\n            \n        except Exception as e:\n            self.errors.append(f\"Monitoring system validation failed: {e}\")\n            print(f\"  ‚ùå Monitoring system validation failed: {e}\")\n    \n    def _validate_documentation(self) -> None:\n        \"\"\"Validate documentation.\"\"\"\n        print(\"\\nüìö Validating Documentation...\")\n        \n        required_docs = [\n            'docs/security.md',\n            'book-frontend/docs/profile-management.md',\n            'README.md',\n        ]\n        \n        present_docs = []\n        missing_docs = []\n        \n        for doc_path in required_docs:\n            if os.path.exists(doc_path):\n                present_docs.append(doc_path)\n                print(f\"  ‚úÖ {doc_path}\")\n            else:\n                missing_docs.append(doc_path)\n                print(f\"  ‚ö†Ô∏è  {doc_path} - MISSING\")\n        \n        if missing_docs:\n            self.recommendations.extend([f\"Consider adding documentation: {d}\" for d in missing_docs])\n        \n        self.validation_results['documentation'] = {\n            'status': 'passed',  # Documentation is not critical for functionality\n            'present_docs': len(present_docs),\n            'missing_docs': len(missing_docs),\n            'total_docs': len(required_docs)\n        }\n    \n    def _check_deployment_readiness(self) -> None:\n        \"\"\"Check deployment readiness.\"\"\"\n        print(\"\\nüöÄ Checking Deployment Readiness...\")\n        \n        readiness_checks = {\n            'no_critical_errors': len(self.errors) == 0,\n            'security_configured': 'security_config' in self.validation_results and \n                                 self.validation_results['security_config']['status'] == 'passed',\n            'files_present': 'file_structure' in self.validation_results and \n                           self.validation_results['file_structure']['status'] == 'passed',\n            'dependencies_installed': 'dependencies' in self.validation_results and \n                                    self.validation_results['dependencies']['status'] == 'passed',\n            'environment_configured': 'environment' in self.validation_results and \n                                    self.validation_results['environment']['status'] == 'passed',\n        }\n        \n        for check, passed in readiness_checks.items():\n            status = \"‚úÖ\" if passed else \"‚ùå\"\n            print(f\"  {status} {check.replace('_', ' ').title()}\")\n        \n        deployment_ready = all(readiness_checks.values())\n        \n        self.validation_results['deployment_readiness'] = {\n            'status': 'ready' if deployment_ready else 'not_ready',\n            'checks': readiness_checks,\n            'passed_checks': sum(readiness_checks.values()),\n            'total_checks': len(readiness_checks)\n        }\n        \n        if deployment_ready:\n            print(\"\\n  üéâ System is ready for deployment!\")\n        else:\n            print(\"\\n  ‚ö†Ô∏è  System needs attention before deployment.\")\n    \n    def _generate_validation_report(self) -> Dict[str, Any]:\n        \"\"\"Generate comprehensive validation report.\"\"\"\n        return {\n            'timestamp': time.time(),\n            'validation_results': self.validation_results,\n            'summary': {\n                'total_errors': len(self.errors),\n                'total_warnings': len(self.warnings),\n                'total_recommendations': len(self.recommendations),\n                'deployment_ready': self.validation_results.get('deployment_readiness', {}).get('status') == 'ready'\n            },\n            'errors': self.errors,\n            'warnings': self.warnings,\n            'recommendations': self.recommendations,\n            'environment': {\n                'python_version': sys.version,\n                'platform': sys.platform,\n                'working_directory': os.getcwd()\n            }\n        }\n    \n    def print_summary(self, report: Dict[str, Any]) -> None:\n        \"\"\"Print validation summary.\"\"\"\n        summary = report['summary']\n        \n        print(\"\\n\" + \"=\" * 50)\n        print(\"üìã VALIDATION SUMMARY\")\n        print(\"=\" * 50)\n        \n        print(f\"Errors:          {summary['total_errors']} ‚ùå\")\n        print(f\"Warnings:        {summary['total_warnings']} ‚ö†Ô∏è\")\n        print(f\"Recommendations: {summary['total_recommendations']} üí°\")\n        print(f\"Deployment Ready: {'Yes' if summary['deployment_ready'] else 'No'} {'‚úÖ' if summary['deployment_ready'] else '‚ùå'}\")\n        \n        if self.errors:\n            print(\"\\n‚ùå ERRORS TO FIX:\")\n            for i, error in enumerate(self.errors[:5], 1):\n                print(f\"  {i}. {error}\")\n            if len(self.errors) > 5:\n                print(f\"  ... and {len(self.errors) - 5} more\")\n        \n        if self.warnings:\n            print(\"\\n‚ö†Ô∏è  WARNINGS:\")\n            for i, warning in enumerate(self.warnings[:3], 1):\n                print(f\"  {i}. {warning}\")\n            if len(self.warnings) > 3:\n                print(f\"  ... and {len(self.warnings) - 3} more\")\n        \n        if self.recommendations:\n            print(\"\\nüí° RECOMMENDATIONS:\")\n            for i, rec in enumerate(self.recommendations[:3], 1):\n                print(f\"  {i}. {rec}\")\n            if len(self.recommendations) > 3:\n                print(f\"  ... and {len(self.recommendations) - 3} more\")\n        \n        print(\"\\n\" + \"=\" * 50)\n\n\ndef main():\n    \"\"\"Main validation function.\"\"\"\n    validator = AuthSystemValidator()\n    \n    try:\n        report = validator.validate_system()\n        validator.print_summary(report)\n        \n        # Save report\n        with open(\"auth_validation_report.json\", \"w\") as f:\n            json.dump(report, f, indent=2)\n        print(f\"\\nüìÑ Validation report saved to: auth_validation_report.json\")\n        \n        # Exit with appropriate code\n        if report['summary']['deployment_ready']:\n            print(\"\\nüéâ Authentication system validation PASSED!\")\n            sys.exit(0)\n        else:\n            print(\"\\n‚ùå Authentication system validation FAILED!\")\n            sys.exit(1)\n            \n    except KeyboardInterrupt:\n        print(\"\\n\\n‚èπÔ∏è  Validation interrupted by user\")\n        sys.exit(130)\n    except Exception as e:\n        print(f\"\\n\\nüí• Validation failed: {e}\")\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()\n"