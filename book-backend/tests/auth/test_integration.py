"""
Integration tests for authentication system.
"""

import pytest
import asyncio
import time
from unittest.mock import Mock, patch, AsyncMock
from fastapi.testclient import TestClient
from fastapi import FastAPI
from src.auth.routes import router as auth_router
from src.auth.error_handling import auth_error_handler
from src.auth.error_monitoring import security_monitor
from src.auth.fallback_mechanisms import fallback_manager
from src.security.security_integration import setup_comprehensive_security
from src.security.security_config import SecurityConfig, SecurityLevel


@pytest.fixture
def secure_app():
    \"\"\"Create FastAPI app with full security setup.\"\"\"\n    app = FastAPI()\n    app.include_router(auth_router)\n    \n    # Set up comprehensive security\n    security_config = SecurityConfig(\n        environment=\"test\",\n        security_level=SecurityLevel.HIGH,\n        enable_rate_limiting=True,\n        enable_csrf_protection=True,\n        enable_security_headers=True,\n        enable_input_sanitization=True,\n    )\n    \n    setup_comprehensive_security(app, security_config)\n    \n    return app\n\n\n@pytest.fixture\ndef secure_client(secure_app):\n    \"\"\"Create test client with security enabled.\"\"\"\n    return TestClient(secure_app)\n\n\nclass TestSecurityIntegration:\n    \"\"\"Test security system integration.\"\"\"\n    \n    def test_security_headers_present(self, secure_client):\n        \"\"\"Test that security headers are present in responses.\"\"\"\n        response = secure_client.get(\"/security/health\")\n        \n        # Check for security headers\n        expected_headers = [\n            \"X-Content-Type-Options\",\n            \"X-Frame-Options\",\n            \"X-XSS-Protection\",\n            \"Content-Security-Policy\",\n            \"Referrer-Policy\"\n        ]\n        \n        for header in expected_headers:\n            assert header in response.headers\n    \n    def test_rate_limiting_integration(self, secure_client):\n        \"\"\"Test rate limiting integration.\"\"\"\n        # Make multiple requests to trigger rate limiting\n        # Note: This might not work in test environment depending on configuration\n        \n        responses = []\n        for i in range(15):  # Exceed typical rate limit\n            response = secure_client.post(\"/auth/login\", json={\n                \"email\": \"test@example.com\",\n                \"password\": \"TestPass123!\"\n            })\n            responses.append(response.status_code)\n        \n        # Should eventually get rate limited\n        assert 429 in responses or all(code in [401, 422] for code in responses)\n    \n    def test_input_validation_integration(self, secure_client):\n        \"\"\"Test input validation integration.\"\"\"\n        # Test with various malicious inputs\n        malicious_inputs = [\n            \"<script>alert('xss')</script>\",\n            \"'; DROP TABLE users; --\",\n            \"../../../etc/passwd\",\n            \"javascript:alert('xss')\"\n        ]\n        \n        for malicious_input in malicious_inputs:\n            response = secure_client.post(\"/auth/signup\", json={\n                \"email\": malicious_input,\n                \"password\": \"TestPass123!\",\n                \"full_name\": malicious_input\n            })\n            \n            # Should be rejected or sanitized\n            assert response.status_code in [400, 422]\n    \n    def test_error_handling_integration(self, secure_client):\n        \"\"\"Test error handling integration.\"\"\"\n        # Test invalid login\n        response = secure_client.post(\"/auth/login\", json={\n            \"email\": \"nonexistent@example.com\",\n            \"password\": \"WrongPass123!\"\n        })\n        \n        assert response.status_code == 401\n        \n        error_data = response.json()\n        assert \"detail\" in error_data\n        assert \"error_code\" in error_data or \"detail\" in error_data\n    \n    def test_security_monitoring_integration(self, secure_client):\n        \"\"\"Test security monitoring integration.\"\"\"\n        # Generate some security events\n        for i in range(3):\n            secure_client.post(\"/auth/login\", json={\n                \"email\": f\"test{i}@example.com\",\n                \"password\": \"WrongPass123!\"\n            })\n        \n        # Check if events were recorded\n        # This would require access to the monitoring system\n        # For now, just verify the endpoints work\n        response = secure_client.get(\"/security/status\")\n        assert response.status_code == 200\n\n\nclass TestErrorHandlingIntegration:\n    \"\"\"Test error handling system integration.\"\"\"\n    \n    def test_error_statistics_tracking(self):\n        \"\"\"Test that errors are tracked in statistics.\"\"\"\n        initial_stats = auth_error_handler.get_error_statistics()\n        initial_count = initial_stats[\"total_errors\"]\n        \n        # Generate some errors\n        for i in range(3):\n            auth_error_handler.create_error(\n                error_type=\"invalid_credentials\",\n                message=f\"Test error {i}\"\n            )\n        \n        updated_stats = auth_error_handler.get_error_statistics()\n        assert updated_stats[\"total_errors\"] == initial_count + 3\n    \n    def test_error_response_format(self, secure_client):\n        \"\"\"Test standardized error response format.\"\"\"\n        response = secure_client.post(\"/auth/login\", json={\n            \"email\": \"invalid@example.com\",\n            \"password\": \"WrongPass123!\"\n        })\n        \n        assert response.status_code == 401\n        \n        error_data = response.json()\n        # Check for standardized error format\n        assert \"detail\" in error_data\n        \n        # Check for WWW-Authenticate header\n        assert \"WWW-Authenticate\" in response.headers\n    \n    def test_error_logging(self, caplog):\n        \"\"\"Test that errors are properly logged.\"\"\"\n        with caplog.at_level(\"WARNING\"):\n            auth_error_handler.create_error(\n                error_type=\"security_violation\",\n                message=\"Test security violation\",\n                severity=\"high\"\n            )\n        \n        # Check that error was logged\n        assert len(caplog.records) > 0\n        assert \"security violation\" in caplog.text.lower()\n\n\nclass TestMonitoringIntegration:\n    \"\"\"Test monitoring system integration.\"\"\"\n    \n    def test_security_metrics_collection(self):\n        \"\"\"Test security metrics collection.\"\"\"\n        # Record some security events\n        security_monitor.metrics.record_failed_login(\n            \"test_user\", \"192.168.1.1\", \"Mozilla/5.0\"\n        )\n        security_monitor.metrics.record_successful_login(\n            \"test_user\", \"192.168.1.1\", \"Mozilla/5.0\"\n        )\n        security_monitor.metrics.record_security_violation(\n            \"XSS attempt\", \"192.168.1.100\", {\"payload\": \"<script>\"}\n        )\n        \n        metrics = security_monitor.metrics.get_metrics()\n        \n        assert metrics[\"current_window\"][\"failed_logins\"] >= 1\n        assert metrics[\"current_window\"][\"successful_logins\"] >= 1\n        assert metrics[\"current_window\"][\"security_violations\"] >= 1\n    \n    def test_alert_generation(self):\n        \"\"\"Test alert generation from metrics.\"\"\"\n        # Generate high number of failed logins to trigger alert\n        for i in range(20):\n            security_monitor.metrics.record_failed_login(\n                f\"user{i}\", \"192.168.1.1\", \"Mozilla/5.0\"\n            )\n        \n        # Check for alerts\n        alerts = security_monitor.alert_manager.check_metrics_for_alerts(\n            security_monitor.metrics\n        )\n        \n        assert len(alerts) > 0\n        assert any(\"failed_login\" in alert.alert_type for alert in alerts)\n    \n    def test_dashboard_data(self):\n        \"\"\"Test security dashboard data.\"\"\"\n        dashboard_data = security_monitor.get_security_dashboard()\n        \n        assert \"metrics\" in dashboard_data\n        assert \"alerts\" in dashboard_data\n        assert \"monitoring_status\" in dashboard_data\n        \n        assert \"current_window\" in dashboard_data[\"metrics\"]\n        assert \"totals\" in dashboard_data[\"metrics\"]\n\n\nclass TestFallbackIntegration:\n    \"\"\"Test fallback mechanisms integration.\"\"\"\n    \n    def test_circuit_breaker_integration(self):\n        \"\"\"Test circuit breaker integration.\"\"\"\n        circuit_breaker = fallback_manager.get_circuit_breaker(\"test_service\")\n        \n        # Test successful operation\n        def success_func():\n            return \"success\"\n        \n        result = circuit_breaker.call(success_func)\n        assert result == \"success\"\n        assert circuit_breaker.state == \"CLOSED\"\n    \n    def test_health_check_integration(self):\n        \"\"\"Test health check integration.\"\"\"\n        health_report = fallback_manager.health_checker.get_health_report()\n        \n        assert \"overall_status\" in health_report\n        assert \"services\" in health_report\n        assert \"last_check_times\" in health_report\n    \n    def test_maintenance_mode_integration(self):\n        \"\"\"Test maintenance mode integration.\"\"\"\n        # Enable maintenance mode\n        fallback_manager.enable_maintenance_mode(\"Test maintenance\")\n        \n        status = fallback_manager.get_fallback_status()\n        assert status[\"maintenance_mode\"] is True\n        \n        # Disable maintenance mode\n        fallback_manager.disable_maintenance_mode()\n        \n        status = fallback_manager.get_fallback_status()\n        assert status[\"maintenance_mode\"] is False\n\n\nclass TestEndToEndFlows:\n    \"\"\"Test complete end-to-end authentication flows.\"\"\"\n    \n    def test_complete_user_journey(self, secure_client):\n        \"\"\"Test complete user authentication journey.\"\"\"\n        # 1. User registration\n        signup_response = secure_client.post(\"/auth/signup\", json={\n            \"email\": \"journey@example.com\",\n            \"password\": \"JourneyPass123!\",\n            \"full_name\": \"Journey User\"\n        })\n        \n        assert signup_response.status_code == 200\n        signup_data = signup_response.json()\n        assert \"access_token\" in signup_data\n        \n        # 2. Access protected resource\n        headers = {\"Authorization\": f\"Bearer {signup_data['access_token']}\"}\n        profile_response = secure_client.get(\"/auth/me\", headers=headers)\n        \n        assert profile_response.status_code == 200\n        profile_data = profile_response.json()\n        assert profile_data[\"email\"] == \"journey@example.com\"\n        \n        # 3. Update profile\n        update_response = secure_client.put(\"/auth/me\", \n            headers=headers,\n            json={\"full_name\": \"Updated Journey User\"}\n        )\n        \n        assert update_response.status_code == 200\n        updated_data = update_response.json()\n        assert updated_data[\"full_name\"] == \"Updated Journey User\"\n        \n        # 4. Token refresh\n        refresh_response = secure_client.post(\"/auth/refresh\", json={\n            \"refresh_token\": signup_data[\"refresh_token\"]\n        })\n        \n        assert refresh_response.status_code == 200\n        refresh_data = refresh_response.json()\n        assert \"access_token\" in refresh_data\n        \n        # 5. Logout\n        logout_response = secure_client.post(\"/auth/logout\", headers=headers)\n        \n        assert logout_response.status_code == 200\n        assert \"success\" in logout_response.json()[\"message\"].lower()\n    \n    def test_security_violation_handling(self, secure_client):\n        \"\"\"Test handling of security violations.\"\"\"\n        # Attempt multiple malicious requests\n        malicious_requests = [\n            {\"email\": \"<script>alert('xss')</script>\", \"password\": \"Test123!\"},\n            {\"email\": \"'; DROP TABLE users; --\", \"password\": \"Test123!\"},\n            {\"email\": \"../../../etc/passwd\", \"password\": \"Test123!\"},\n        ]\n        \n        violation_responses = []\n        for request_data in malicious_requests:\n            response = secure_client.post(\"/auth/login\", json=request_data)\n            violation_responses.append(response.status_code)\n        \n        # All should be rejected\n        assert all(code in [400, 401, 422] for code in violation_responses)\n    \n    def test_rate_limiting_recovery(self, secure_client):\n        \"\"\"Test rate limiting and recovery.\"\"\"\n        # This test would need to be adjusted based on actual rate limiting configuration\n        # For now, just test that the system handles multiple requests gracefully\n        \n        responses = []\n        for i in range(10):\n            response = secure_client.post(\"/auth/login\", json={\n                \"email\": f\"ratetest{i}@example.com\",\n                \"password\": \"TestPass123!\"\n            })\n            responses.append(response.status_code)\n        \n        # Should handle all requests without crashing\n        assert all(isinstance(code, int) and 200 <= code < 600 for code in responses)\n    \n    def test_concurrent_authentication(self, secure_client):\n        \"\"\"Test concurrent authentication requests.\"\"\"\n        import threading\n        import queue\n        \n        results = queue.Queue()\n        \n        def authenticate_user(user_id):\n            try:\n                # Register user\n                signup_response = secure_client.post(\"/auth/signup\", json={\n                    \"email\": f\"concurrent{user_id}@example.com\",\n                    \"password\": \"ConcurrentPass123!\",\n                    \"full_name\": f\"Concurrent User {user_id}\"\n                })\n                \n                # Login user\n                login_response = secure_client.post(\"/auth/login\", json={\n                    \"email\": f\"concurrent{user_id}@example.com\",\n                    \"password\": \"ConcurrentPass123!\"\n                })\n                \n                results.put({\n                    \"user_id\": user_id,\n                    \"signup_status\": signup_response.status_code,\n                    \"login_status\": login_response.status_code\n                })\n            except Exception as e:\n                results.put({\n                    \"user_id\": user_id,\n                    \"error\": str(e)\n                })\n        \n        # Create multiple threads\n        threads = []\n        for i in range(5):\n            thread = threading.Thread(target=authenticate_user, args=(i,))\n            threads.append(thread)\n            thread.start()\n        \n        # Wait for all threads to complete\n        for thread in threads:\n            thread.join()\n        \n        # Collect results\n        thread_results = []\n        while not results.empty():\n            thread_results.append(results.get())\n        \n        assert len(thread_results) == 5\n        \n        # Check that most requests succeeded (some might fail due to rate limiting)\n        successful_signups = sum(1 for r in thread_results if r.get(\"signup_status\") == 200)\n        assert successful_signups >= 3  # At least 3 out of 5 should succeed\n\n\nclass TestPerformanceAndLoad:\n    \"\"\"Test performance and load handling.\"\"\"\n    \n    def test_authentication_performance(self, secure_client):\n        \"\"\"Test authentication performance.\"\"\"\n        import time\n        \n        # Register a user first\n        secure_client.post(\"/auth/signup\", json={\n            \"email\": \"perf@example.com\",\n            \"password\": \"PerfPass123!\",\n            \"full_name\": \"Performance User\"\n        })\n        \n        # Measure login performance\n        start_time = time.time()\n        \n        for i in range(10):\n            response = secure_client.post(\"/auth/login\", json={\n                \"email\": \"perf@example.com\",\n                \"password\": \"PerfPass123!\"\n            })\n            # Should succeed or fail quickly\n            assert response.status_code in [200, 401, 429]\n        \n        end_time = time.time()\n        total_time = end_time - start_time\n        \n        # Should complete 10 requests in reasonable time (adjust as needed)\n        assert total_time < 10.0  # 10 seconds for 10 requests\n        \n        avg_time = total_time / 10\n        assert avg_time < 1.0  # Average less than 1 second per request\n    \n    def test_memory_usage_stability(self, secure_client):\n        \"\"\"Test that memory usage remains stable under load.\"\"\"\n        import gc\n        import sys\n        \n        # Force garbage collection\n        gc.collect()\n        initial_objects = len(gc.get_objects())\n        \n        # Perform many authentication operations\n        for i in range(50):\n            secure_client.post(\"/auth/signup\", json={\n                \"email\": f\"memory{i}@example.com\",\n                \"password\": \"MemoryPass123!\",\n                \"full_name\": f\"Memory User {i}\"\n            })\n        \n        # Force garbage collection again\n        gc.collect()\n        final_objects = len(gc.get_objects())\n        \n        # Object count shouldn't grow excessively\n        object_growth = final_objects - initial_objects\n        assert object_growth < 1000  # Reasonable growth limit\n\n\nif __name__ == \"__main__\":\n    pytest.main([__file__])\n"