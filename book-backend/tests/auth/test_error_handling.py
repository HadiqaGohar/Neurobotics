"""
Tests for authentication error handling system.
"""

import pytest
import time
from unittest.mock import Mock, patch, AsyncMock
from fastapi import HTTPException, status, Request
from src.auth.error_handling import (\n    AuthError,\n    AuthErrorType,\n    AuthErrorSeverity,\n    AuthErrorHandler,\n    auth_error_handler,\n    invalid_credentials_error,\n    token_expired_error,\n    permission_denied_error,\n    rate_limit_exceeded_error,\n    security_violation_error\n)\nfrom src.auth.error_monitoring import (\n    SecurityMetrics,\n    SecurityAlertManager,\n    SecurityMonitor,\n    AlertLevel,\n    record_failed_login,\n    record_successful_login,\n    create_security_alert\n)\nfrom src.auth.fallback_mechanisms import (\n    AuthFallbackManager,\n    CircuitBreaker,\n    FallbackStrategy,\n    ServiceStatus,\n    execute_with_fallback\n)\n\n\nclass TestAuthError:\n    \"\"\"Test AuthError class functionality.\"\"\"\n    \n    def test_auth_error_creation(self):\n        \"\"\"Test creating an AuthError.\"\"\"\n        error = AuthError(\n            error_type=AuthErrorType.INVALID_CREDENTIALS,\n            message=\"Invalid login\",\n            details={\"user_id\": \"test_user\"},\n            severity=AuthErrorSeverity.MEDIUM\n        )\n        \n        assert error.error_type == AuthErrorType.INVALID_CREDENTIALS\n        assert error.message == \"Invalid login\"\n        assert error.details[\"user_id\"] == \"test_user\"\n        assert error.severity == AuthErrorSeverity.MEDIUM\n        assert error.status_code == status.HTTP_401_UNAUTHORIZED\n        assert error.error_id is not None\n        assert error.timestamp > 0\n    \n    def test_auth_error_inheritance(self):\n        \"\"\"Test that AuthError inherits from Exception.\"\"\"\n        error = AuthError(\n            error_type=AuthErrorType.TOKEN_EXPIRED,\n            message=\"Token expired\"\n        )\n        \n        assert isinstance(error, Exception)\n        assert str(error) == \"Token expired\"\n\n\nclass TestAuthErrorHandler:\n    \"\"\"Test AuthErrorHandler functionality.\"\"\"\n    \n    def setup_method(self):\n        \"\"\"Set up test fixtures.\"\"\"\n        self.handler = AuthErrorHandler()\n    \n    def test_create_error_with_defaults(self):\n        \"\"\"Test creating error with default values.\"\"\"\n        error = self.handler.create_error(\n            AuthErrorType.INVALID_CREDENTIALS\n        )\n        \n        assert error.error_type == AuthErrorType.INVALID_CREDENTIALS\n        assert error.message == \"Invalid email or password. Please try again.\"\n        assert error.status_code == status.HTTP_401_UNAUTHORIZED\n        assert error.severity == AuthErrorSeverity.MEDIUM\n    \n    def test_create_error_with_custom_values(self):\n        \"\"\"Test creating error with custom values.\"\"\"\n        error = self.handler.create_error(\n            error_type=AuthErrorType.RATE_LIMIT_EXCEEDED,\n            message=\"Custom rate limit message\",\n            details={\"limit\": 10, \"window\": 60},\n            status_code=429,\n            severity=AuthErrorSeverity.HIGH,\n            retry_after=120\n        )\n        \n        assert error.message == \"Custom rate limit message\"\n        assert error.details[\"limit\"] == 10\n        assert error.status_code == 429\n        assert error.severity == AuthErrorSeverity.HIGH\n        assert error.retry_after == 120\n    \n    def test_handle_http_exception(self):\n        \"\"\"Test handling HTTPException.\"\"\"\n        http_exc = HTTPException(\n            status_code=403,\n            detail=\"Forbidden access\"\n        )\n        \n        error = self.handler.handle_error(http_exc)\n        \n        assert error.error_type == AuthErrorType.PERMISSION_DENIED\n        assert error.message == \"Forbidden access\"\n        assert error.status_code == 403\n    \n    def test_handle_unexpected_exception(self):\n        \"\"\"Test handling unexpected exception.\"\"\"\n        unexpected_exc = ValueError(\"Unexpected error\")\n        \n        error = self.handler.handle_error(unexpected_exc)\n        \n        assert error.error_type == AuthErrorType.INTERNAL_ERROR\n        assert \"unexpected error\" in error.message.lower()\n        assert error.severity == AuthErrorSeverity.HIGH\n        assert error.details[\"original_error\"] == \"Unexpected error\"\n    \n    def test_create_response(self):\n        \"\"\"Test creating error response.\"\"\"\n        error = AuthError(\n            error_type=AuthErrorType.TOKEN_EXPIRED,\n            message=\"Token has expired\",\n            retry_after=60\n        )\n        \n        response = self.handler.create_response(error, \"req_123\")\n        \n        assert response.status_code == status.HTTP_401_UNAUTHORIZED\n        assert \"WWW-Authenticate\" in response.headers\n        assert response.headers[\"Retry-After\"] == \"60\"\n        \n        content = response.body.decode()\n        assert \"token_expired\" in content\n        assert \"req_123\" in content\n    \n    def test_error_statistics(self):\n        \"\"\"Test error statistics tracking.\"\"\"\n        # Create several errors\n        for _ in range(3):\n            self.handler.create_error(AuthErrorType.INVALID_CREDENTIALS)\n        \n        for _ in range(2):\n            self.handler.create_error(AuthErrorType.TOKEN_EXPIRED)\n        \n        stats = self.handler.get_error_statistics()\n        \n        assert stats[\"total_errors\"] == 5\n        assert stats[\"error_counts\"][\"invalid_credentials\"] == 3\n        assert stats[\"error_counts\"][\"token_expired\"] == 2\n        assert len(stats[\"most_common_errors\"]) > 0\n    \n    def test_clear_statistics(self):\n        \"\"\"Test clearing error statistics.\"\"\"\n        self.handler.create_error(AuthErrorType.INVALID_CREDENTIALS)\n        \n        stats_before = self.handler.get_error_statistics()\n        assert stats_before[\"total_errors\"] > 0\n        \n        self.handler.clear_statistics()\n        \n        stats_after = self.handler.get_error_statistics()\n        assert stats_after[\"total_errors\"] == 0\n\n\nclass TestConvenienceFunctions:\n    \"\"\"Test convenience functions for common errors.\"\"\"\n    \n    def test_invalid_credentials_error(self):\n        \"\"\"Test invalid credentials error function.\"\"\"\n        error = invalid_credentials_error({\"attempt\": 1})\n        \n        assert error.error_type == AuthErrorType.INVALID_CREDENTIALS\n        assert error.details[\"attempt\"] == 1\n        assert error.severity == AuthErrorSeverity.MEDIUM\n    \n    def test_token_expired_error(self):\n        \"\"\"Test token expired error function.\"\"\"\n        error = token_expired_error({\"token_age\": 3600})\n        \n        assert error.error_type == AuthErrorType.TOKEN_EXPIRED\n        assert error.details[\"token_age\"] == 3600\n        assert error.severity == AuthErrorSeverity.LOW\n    \n    def test_permission_denied_error(self):\n        \"\"\"Test permission denied error function.\"\"\"\n        error = permission_denied_error(\"admin_panel\", {\"user_role\": \"user\"})\n        \n        assert error.error_type == AuthErrorType.PERMISSION_DENIED\n        assert \"admin_panel\" in error.message\n        assert error.details[\"user_role\"] == \"user\"\n    \n    def test_rate_limit_exceeded_error(self):\n        \"\"\"Test rate limit exceeded error function.\"\"\"\n        error = rate_limit_exceeded_error(120, {\"requests\": 100})\n        \n        assert error.error_type == AuthErrorType.RATE_LIMIT_EXCEEDED\n        assert error.retry_after == 120\n        assert error.details[\"requests\"] == 100\n        assert error.severity == AuthErrorSeverity.HIGH\n    \n    def test_security_violation_error(self):\n        \"\"\"Test security violation error function.\"\"\"\n        error = security_violation_error(\"SQL injection\", {\"query\": \"malicious\"})\n        \n        assert error.error_type == AuthErrorType.SECURITY_VIOLATION\n        assert \"SQL injection\" in error.message\n        assert error.details[\"query\"] == \"malicious\"\n        assert error.severity == AuthErrorSeverity.CRITICAL\n\n\nclass TestSecurityMetrics:\n    \"\"\"Test SecurityMetrics functionality.\"\"\"\n    \n    def setup_method(self):\n        \"\"\"Set up test fixtures.\"\"\"\n        self.metrics = SecurityMetrics(window_size=3600)  # 1 hour\n    \n    def test_record_failed_login(self):\n        \"\"\"Test recording failed login attempts.\"\"\"\n        self.metrics.record_failed_login(\"user123\", \"192.168.1.1\", \"Mozilla/5.0\")\n        \n        assert self.metrics.total_failed_logins == 1\n        assert len(self.metrics.failed_logins) == 1\n        assert \"user123\" in self.metrics.user_failed_attempts\n        assert \"192.168.1.1\" in self.metrics.ip_failed_attempts\n    \n    def test_record_successful_login(self):\n        \"\"\"Test recording successful login attempts.\"\"\"\n        self.metrics.record_successful_login(\"user123\", \"192.168.1.1\", \"Mozilla/5.0\")\n        \n        assert self.metrics.total_successful_logins == 1\n        assert len(self.metrics.successful_logins) == 1\n    \n    def test_record_security_violation(self):\n        \"\"\"Test recording security violations.\"\"\"\n        self.metrics.record_security_violation(\n            \"XSS attempt\", \n            \"192.168.1.100\", \n            {\"payload\": \"<script>alert('xss')</script>\"}\n        )\n        \n        assert self.metrics.total_security_violations == 1\n        assert len(self.metrics.security_violations) == 1\n        assert \"192.168.1.100\" in self.metrics.suspicious_ips\n    \n    def test_suspicious_pattern_detection(self):\n        \"\"\"Test detection of suspicious patterns.\"\"\"\n        # Simulate multiple failed attempts from same IP\n        for i in range(12):\n            self.metrics.record_failed_login(f\"user{i}\", \"192.168.1.1\", \"Mozilla/5.0\")\n        \n        assert \"192.168.1.1\" in self.metrics.suspicious_ips\n    \n    def test_get_metrics(self):\n        \"\"\"Test getting metrics summary.\"\"\"\n        # Add some test data\n        self.metrics.record_failed_login(\"user1\", \"192.168.1.1\", \"Mozilla/5.0\")\n        self.metrics.record_successful_login(\"user2\", \"192.168.1.2\", \"Mozilla/5.0\")\n        self.metrics.record_rate_limit_violation(\"192.168.1.3\", \"/api/login\", \"Mozilla/5.0\")\n        \n        metrics = self.metrics.get_metrics()\n        \n        assert \"current_window\" in metrics\n        assert \"totals\" in metrics\n        assert \"suspicious_activity\" in metrics\n        assert \"success_rate\" in metrics\n        \n        assert metrics[\"current_window\"][\"failed_logins\"] == 1\n        assert metrics[\"current_window\"][\"successful_logins\"] == 1\n        assert metrics[\"success_rate\"] == 0.5  # 50% success rate\n\n\nclass TestSecurityAlertManager:\n    \"\"\"Test SecurityAlertManager functionality.\"\"\"\n    \n    def setup_method(self):\n        \"\"\"Set up test fixtures.\"\"\"\n        self.alert_manager = SecurityAlertManager()\n    \n    def test_create_alert(self):\n        \"\"\"Test creating security alerts.\"\"\"\n        alert = self.alert_manager.create_alert(\n            alert_type=\"test_alert\",\n            level=AlertLevel.WARNING,\n            message=\"Test alert message\",\n            details={\"test\": \"data\"},\n            affected_user=\"user123\"\n        )\n        \n        assert alert.alert_type == \"test_alert\"\n        assert alert.level == AlertLevel.WARNING\n        assert alert.message == \"Test alert message\"\n        assert alert.details[\"test\"] == \"data\"\n        assert alert.affected_user == \"user123\"\n        assert alert.alert_id is not None\n    \n    def test_alert_handler(self):\n        \"\"\"Test alert handler functionality.\"\"\"\n        handler_called = False\n        received_alert = None\n        \n        def test_handler(alert):\n            nonlocal handler_called, received_alert\n            handler_called = True\n            received_alert = alert\n        \n        self.alert_manager.add_alert_handler(test_handler)\n        \n        alert = self.alert_manager.create_alert(\n            \"test_alert\",\n            AlertLevel.ERROR,\n            \"Test message\",\n            {}\n        )\n        \n        assert handler_called\n        assert received_alert == alert\n    \n    def test_check_metrics_for_alerts(self):\n        \"\"\"Test checking metrics and generating alerts.\"\"\"\n        metrics = SecurityMetrics(window_size=3600)\n        \n        # Generate high failed login rate\n        for i in range(15):\n            metrics.record_failed_login(f\"user{i}\", \"192.168.1.1\", \"Mozilla/5.0\")\n        \n        alerts = self.alert_manager.check_metrics_for_alerts(metrics)\n        \n        assert len(alerts) > 0\n        assert any(alert.alert_type == \"high_failed_login_rate\" for alert in alerts)\n    \n    def test_get_recent_alerts(self):\n        \"\"\"Test getting recent alerts.\"\"\"\n        # Create alerts with different levels\n        self.alert_manager.create_alert(\"test1\", AlertLevel.INFO, \"Info alert\", {})\n        self.alert_manager.create_alert(\"test2\", AlertLevel.WARNING, \"Warning alert\", {})\n        self.alert_manager.create_alert(\"test3\", AlertLevel.ERROR, \"Error alert\", {})\n        \n        # Get all recent alerts\n        all_alerts = self.alert_manager.get_recent_alerts(24)\n        assert len(all_alerts) == 3\n        \n        # Get only error alerts\n        error_alerts = self.alert_manager.get_recent_alerts(24, AlertLevel.ERROR)\n        assert len(error_alerts) == 1\n        assert error_alerts[0].level == AlertLevel.ERROR\n    \n    def test_resolve_alert(self):\n        \"\"\"Test resolving alerts.\"\"\"\n        alert = self.alert_manager.create_alert(\n            \"test_alert\",\n            AlertLevel.WARNING,\n            \"Test alert\",\n            {}\n        )\n        \n        assert not alert.resolved\n        \n        success = self.alert_manager.resolve_alert(alert.alert_id, \"Fixed the issue\")\n        \n        assert success\n        assert alert.resolved\n        assert alert.resolution_notes == \"Fixed the issue\"\n    \n    def test_get_alert_summary(self):\n        \"\"\"Test getting alert summary.\"\"\"\n        # Create various alerts\n        self.alert_manager.create_alert(\"type1\", AlertLevel.INFO, \"Info\", {})\n        self.alert_manager.create_alert(\"type1\", AlertLevel.WARNING, \"Warning\", {})\n        self.alert_manager.create_alert(\"type2\", AlertLevel.ERROR, \"Error\", {})\n        \n        summary = self.alert_manager.get_alert_summary()\n        \n        assert \"total_alerts_24h\" in summary\n        assert \"alerts_by_level\" in summary\n        assert \"alerts_by_type\" in summary\n        assert \"most_recent_alert\" in summary\n        \n        assert summary[\"total_alerts_24h\"] == 3\n        assert summary[\"alerts_by_type\"][\"type1\"] == 2\n        assert summary[\"alerts_by_type\"][\"type2\"] == 1\n\n\nclass TestCircuitBreaker:\n    \"\"\"Test CircuitBreaker functionality.\"\"\"\n    \n    def setup_method(self):\n        \"\"\"Set up test fixtures.\"\"\"\n        self.circuit_breaker = CircuitBreaker(\n            failure_threshold=3,\n            recovery_timeout=60\n        )\n    \n    def test_successful_calls(self):\n        \"\"\"Test successful function calls.\"\"\"\n        def success_func():\n            return \"success\"\n        \n        result = self.circuit_breaker.call(success_func)\n        assert result == \"success\"\n        assert self.circuit_breaker.state == \"CLOSED\"\n        assert self.circuit_breaker.failure_count == 0\n    \n    def test_circuit_breaker_opens_on_failures(self):\n        \"\"\"Test that circuit breaker opens after threshold failures.\"\"\"\n        def failing_func():\n            raise Exception(\"Function failed\")\n        \n        # Call function until circuit breaker opens\n        for i in range(3):\n            with pytest.raises(Exception):\n                self.circuit_breaker.call(failing_func)\n        \n        assert self.circuit_breaker.state == \"OPEN\"\n        assert self.circuit_breaker.failure_count == 3\n        \n        # Next call should be blocked by circuit breaker\n        with pytest.raises(Exception, match=\"Circuit breaker is OPEN\"):\n            self.circuit_breaker.call(failing_func)\n    \n    @pytest.mark.asyncio\n    async def test_async_circuit_breaker(self):\n        \"\"\"Test circuit breaker with async functions.\"\"\"\n        async def async_success_func():\n            return \"async_success\"\n        \n        result = await self.circuit_breaker.call_async(async_success_func)\n        assert result == \"async_success\"\n        assert self.circuit_breaker.state == \"CLOSED\"\n\n\nclass TestAuthFallbackManager:\n    \"\"\"Test AuthFallbackManager functionality.\"\"\"\n    \n    def setup_method(self):\n        \"\"\"Set up test fixtures.\"\"\"\n        self.fallback_manager = AuthFallbackManager()\n    \n    @pytest.mark.asyncio\n    async def test_execute_with_fallback_success(self):\n        \"\"\"Test successful execution with fallback manager.\"\"\"\n        async def primary_func():\n            return \"primary_success\"\n        \n        result = await self.fallback_manager.execute_with_fallback(\n            \"test_operation\",\n            primary_func\n        )\n        \n        assert result == \"primary_success\"\n    \n    @pytest.mark.asyncio\n    async def test_execute_with_fallback_failure(self):\n        \"\"\"Test fallback execution when primary fails.\"\"\"\n        async def failing_primary():\n            raise Exception(\"Primary failed\")\n        \n        async def fallback_func():\n            return \"fallback_success\"\n        \n        # This test would need more setup to work properly\n        # For now, just test that the manager handles the error\n        with pytest.raises(Exception):\n            await self.fallback_manager.execute_with_fallback(\n                \"test_operation\",\n                failing_primary,\n                fallback_func\n            )\n    \n    def test_maintenance_mode(self):\n        \"\"\"Test maintenance mode functionality.\"\"\"\n        assert not self.fallback_manager.maintenance_mode\n        \n        self.fallback_manager.enable_maintenance_mode(\"System maintenance\")\n        assert self.fallback_manager.maintenance_mode\n        \n        self.fallback_manager.disable_maintenance_mode()\n        assert not self.fallback_manager.maintenance_mode\n    \n    def test_get_fallback_status(self):\n        \"\"\"Test getting fallback status.\"\"\"\n        status = self.fallback_manager.get_fallback_status()\n        \n        assert \"maintenance_mode\" in status\n        assert \"offline_mode\" in status\n        assert \"circuit_breakers\" in status\n        assert \"cached_responses\" in status\n        assert \"health_status\" in status\n\n\nclass TestIntegration:\n    \"\"\"Integration tests for error handling system.\"\"\"\n    \n    def test_error_monitoring_integration(self):\n        \"\"\"Test integration between error handling and monitoring.\"\"\"\n        # Record some authentication events\n        record_failed_login(\"user123\", \"192.168.1.1\", \"Mozilla/5.0\")\n        record_successful_login(\"user456\", \"192.168.1.2\", \"Mozilla/5.0\")\n        \n        # Create a security alert\n        alert = create_security_alert(\n            \"test_integration\",\n            AlertLevel.WARNING,\n            \"Integration test alert\",\n            {\"test\": True}\n        )\n        \n        assert alert.alert_type == \"test_integration\"\n        assert alert.level == AlertLevel.WARNING\n    \n    def test_global_error_handler_integration(self):\n        \"\"\"Test integration with global error handler.\"\"\"\n        # Test that global error handler is available\n        assert auth_error_handler is not None\n        \n        # Create an error using global handler\n        error = auth_error_handler.create_error(\n            AuthErrorType.INVALID_CREDENTIALS,\n            \"Test integration error\"\n        )\n        \n        assert error.error_type == AuthErrorType.INVALID_CREDENTIALS\n        assert error.message == \"Test integration error\"\n        \n        # Check that error was tracked\n        stats = auth_error_handler.get_error_statistics()\n        assert stats[\"total_errors\"] > 0\n\n\nif __name__ == \"__main__\":\n    pytest.main([__file__])\n"