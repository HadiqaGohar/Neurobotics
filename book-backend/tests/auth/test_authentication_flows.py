"""
Comprehensive authentication flow tests.
"""

import pytest
import time
from unittest.mock import Mock, patch, AsyncMock
from fastapi.testclient import TestClient
from fastapi import FastAPI, status
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from src.auth.routes import router as auth_router
from src.auth.better_auth import AuthService
from src.database.models import User, Base
from src.database.database import get_db


@pytest.fixture
def test_db():
    \"\"\"Create test database.\"\"\"\n    engine = create_engine(\"sqlite:///./test_auth.db\", connect_args={\"check_same_thread\": False})\n    TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n    \n    Base.metadata.create_all(bind=engine)\n    \n    def override_get_db():\n        try:\n            db = TestingSessionLocal()\n            yield db\n        finally:\n            db.close()\n    \n    return override_get_db\n\n\n@pytest.fixture\ndef test_app(test_db):\n    \"\"\"Create test FastAPI app.\"\"\"\n    app = FastAPI()\n    app.include_router(auth_router)\n    app.dependency_overrides[get_db] = test_db\n    return app\n\n\n@pytest.fixture\ndef client(test_app):\n    \"\"\"Create test client.\"\"\"\n    return TestClient(test_app)\n\n\nclass TestUserRegistration:\n    \"\"\"Test user registration flow.\"\"\"\n    \n    def test_successful_registration(self, client):\n        \"\"\"Test successful user registration.\"\"\"\n        response = client.post(\"/auth/signup\", json={\n            \"email\": \"test@example.com\",\n            \"password\": \"SecurePass123!\",\n            \"full_name\": \"Test User\"\n        })\n        \n        assert response.status_code == 200\n        data = response.json()\n        \n        assert \"access_token\" in data\n        assert \"refresh_token\" in data\n        assert \"user\" in data\n        assert data[\"user\"][\"email\"] == \"test@example.com\"\n        assert data[\"user\"][\"full_name\"] == \"Test User\"\n    \n    def test_registration_with_weak_password(self, client):\n        \"\"\"Test registration with weak password.\"\"\"\n        response = client.post(\"/auth/signup\", json={\n            \"email\": \"test@example.com\",\n            \"password\": \"weak\",\n            \"full_name\": \"Test User\"\n        })\n        \n        assert response.status_code == 422\n        assert \"password\" in response.json()[\"detail\"][0][\"loc\"]\n    \n    def test_registration_with_invalid_email(self, client):\n        \"\"\"Test registration with invalid email.\"\"\"\n        response = client.post(\"/auth/signup\", json={\n            \"email\": \"invalid-email\",\n            \"password\": \"SecurePass123!\",\n            \"full_name\": \"Test User\"\n        })\n        \n        assert response.status_code == 422\n"    
    d
ef test_duplicate_email_registration(self, client):\n        \"\"\"Test registration with duplicate email.\"\"\"\n        # First registration\n        client.post(\"/auth/signup\", json={\n            \"email\": \"duplicate@example.com\",\n            \"password\": \"SecurePass123!\",\n            \"full_name\": \"First User\"\n        })\n        \n        # Second registration with same email\n        response = client.post(\"/auth/signup\", json={\n            \"email\": \"duplicate@example.com\",\n            \"password\": \"AnotherPass123!\",\n            \"full_name\": \"Second User\"\n        })\n        \n        assert response.status_code == 400\n        assert \"already exists\" in response.json()[\"detail\"].lower()\n\n\nclass TestUserLogin:\n    \"\"\"Test user login flow.\"\"\"\n    \n    def setup_method(self):\n        \"\"\"Set up test user.\"\"\"\n        self.test_user_email = \"login_test@example.com\"\n        self.test_user_password = \"LoginPass123!\"\n    \n    def test_successful_login(self, client):\n        \"\"\"Test successful user login.\"\"\"\n        # First register a user\n        client.post(\"/auth/signup\", json={\n            \"email\": self.test_user_email,\n            \"password\": self.test_user_password,\n            \"full_name\": \"Login Test User\"\n        })\n        \n        # Then login\n        response = client.post(\"/auth/login\", json={\n            \"email\": self.test_user_email,\n            \"password\": self.test_user_password\n        })\n        \n        assert response.status_code == 200\n        data = response.json()\n        \n        assert \"access_token\" in data\n        assert \"refresh_token\" in data\n        assert \"user\" in data\n        assert data[\"user\"][\"email\"] == self.test_user_email\n    \n    def test_login_with_invalid_credentials(self, client):\n        \"\"\"Test login with invalid credentials.\"\"\"\n        response = client.post(\"/auth/login\", json={\n            \"email\": \"nonexistent@example.com\",\n            \"password\": \"WrongPassword123!\"\n        })\n        \n        assert response.status_code == 401\n        assert \"invalid\" in response.json()[\"detail\"].lower()\n    \n    def test_login_with_wrong_password(self, client):\n        \"\"\"Test login with wrong password.\"\"\"\n        # Register user first\n        client.post(\"/auth/signup\", json={\n            \"email\": self.test_user_email,\n            \"password\": self.test_user_password,\n            \"full_name\": \"Test User\"\n        })\n        \n        # Try login with wrong password\n        response = client.post(\"/auth/login\", json={\n            \"email\": self.test_user_email,\n            \"password\": \"WrongPassword123!\"\n        })\n        \n        assert response.status_code == 401\n        assert \"invalid\" in response.json()[\"detail\"].lower()\n\n\nclass TestTokenManagement:\n    \"\"\"Test token management functionality.\"\"\"\n    \n    def setup_method(self):\n        \"\"\"Set up test user and tokens.\"\"\"\n        self.test_user_email = \"token_test@example.com\"\n        self.test_user_password = \"TokenPass123!\"\n    \n    def test_token_refresh(self, client):\n        \"\"\"Test token refresh functionality.\"\"\"\n        # Register and login to get tokens\n        client.post(\"/auth/signup\", json={\n            \"email\": self.test_user_email,\n            \"password\": self.test_user_password,\n            \"full_name\": \"Token Test User\"\n        })\n        \n        login_response = client.post(\"/auth/login\", json={\n            \"email\": self.test_user_email,\n            \"password\": self.test_user_password\n        })\n        \n        tokens = login_response.json()\n        refresh_token = tokens[\"refresh_token\"]\n        \n        # Use refresh token to get new access token\n        response = client.post(\"/auth/refresh\", json={\n            \"refresh_token\": refresh_token\n        })\n        \n        assert response.status_code == 200\n        data = response.json()\n        \n        assert \"access_token\" in data\n        assert \"refresh_token\" in data\n        assert data[\"access_token\"] != tokens[\"access_token\"]  # New token\n    \n    def test_invalid_refresh_token(self, client):\n        \"\"\"Test refresh with invalid token.\"\"\"\n        response = client.post(\"/auth/refresh\", json={\n            \"refresh_token\": \"invalid_token\"\n        })\n        \n        assert response.status_code == 401\n    \n    def test_expired_token_handling(self, client):\n        \"\"\"Test handling of expired tokens.\"\"\"\n        # This would require mocking time or using very short token expiry\n        # For now, test with malformed token\n        headers = {\"Authorization\": \"Bearer expired_or_invalid_token\"}\n        \n        response = client.get(\"/auth/me\", headers=headers)\n        \n        assert response.status_code == 401\n\n\nclass TestProtectedEndpoints:\n    \"\"\"Test protected endpoint access.\"\"\"\n    \n    def setup_method(self):\n        \"\"\"Set up authenticated user.\"\"\"\n        self.test_user_email = \"protected_test@example.com\"\n        self.test_user_password = \"ProtectedPass123!\"\n    \n    def get_auth_headers(self, client):\n        \"\"\"Get authentication headers for requests.\"\"\"\n        # Register and login\n        client.post(\"/auth/signup\", json={\n            \"email\": self.test_user_email,\n            \"password\": self.test_user_password,\n            \"full_name\": \"Protected Test User\"\n        })\n        \n        login_response = client.post(\"/auth/login\", json={\n            \"email\": self.test_user_email,\n            \"password\": self.test_user_password\n        })\n        \n        token = login_response.json()[\"access_token\"]\n        return {\"Authorization\": f\"Bearer {token}\"}\n    \n    def test_access_user_profile(self, client):\n        \"\"\"Test accessing user profile with valid token.\"\"\"\n        headers = self.get_auth_headers(client)\n        \n        response = client.get(\"/auth/me\", headers=headers)\n        \n        assert response.status_code == 200\n        data = response.json()\n        \n        assert data[\"email\"] == self.test_user_email\n        assert \"id\" in data\n        assert \"created_at\" in data\n    \n    def test_access_without_token(self, client):\n        \"\"\"Test accessing protected endpoint without token.\"\"\"\n        response = client.get(\"/auth/me\")\n        \n        assert response.status_code == 401\n    \n    def test_access_with_invalid_token(self, client):\n        \"\"\"Test accessing protected endpoint with invalid token.\"\"\"\n        headers = {\"Authorization\": \"Bearer invalid_token\"}\n        \n        response = client.get(\"/auth/me\", headers=headers)\n        \n        assert response.status_code == 401\n    \n    def test_update_user_profile(self, client):\n        \"\"\"Test updating user profile.\"\"\"\n        headers = self.get_auth_headers(client)\n        \n        response = client.put(\"/auth/me\", \n            headers=headers,\n            json={\"full_name\": \"Updated Name\"}\n        )\n        \n        assert response.status_code == 200\n        data = response.json()\n        \n        assert data[\"full_name\"] == \"Updated Name\"\n    \n    def test_logout(self, client):\n        \"\"\"Test user logout.\"\"\"\n        headers = self.get_auth_headers(client)\n        \n        response = client.post(\"/auth/logout\", headers=headers)\n        \n        assert response.status_code == 200\n        assert \"successfully\" in response.json()[\"message\"].lower()\n\n\nclass TestPasswordSecurity:\n    \"\"\"Test password security features.\"\"\"\n    \n    def test_password_hashing(self):\n        \"\"\"Test that passwords are properly hashed.\"\"\"\n        password = \"TestPassword123!\"\n        hashed = AuthService.hash_password(password)\n        \n        assert hashed != password\n        assert len(hashed) > 50  # Bcrypt hashes are long\n        assert AuthService.verify_password(password, hashed)\n        assert not AuthService.verify_password(\"wrong_password\", hashed)\n    \n    def test_password_strength_validation(self):\n        \"\"\"Test password strength validation.\"\"\"\n        from src.security.input_validation import InputValidator\n        \n        # Test weak passwords\n        weak_passwords = [\n            \"password\",\n            \"123456\",\n            \"short\",\n            \"nouppercase123!\",\n            \"NOLOWERCASE123!\",\n            \"NoNumbers!\",\n            \"NoSpecialChars123\"\n        ]\n        \n        for password in weak_passwords:\n            is_valid, errors = InputValidator.validate_password(password)\n            assert not is_valid\n            assert len(errors) > 0\n        \n        # Test strong password\n        strong_password = \"StrongPassword123!\"\n        is_valid, errors = InputValidator.validate_password(strong_password)\n        assert is_valid\n        assert len(errors) == 0\n\n\nclass TestRateLimiting:\n    \"\"\"Test rate limiting functionality.\"\"\"\n    \n    @patch('src.security.security_utils.rate_limiter.is_allowed')\n    def test_login_rate_limiting(self, mock_rate_limiter, client):\n        \"\"\"Test rate limiting on login endpoint.\"\"\"\n        # Mock rate limiter to return False (rate limited)\n        mock_rate_limiter.return_value = False\n        \n        response = client.post(\"/auth/login\", json={\n            \"email\": \"test@example.com\",\n            \"password\": \"TestPass123!\"\n        })\n        \n        assert response.status_code == 429\n        assert \"rate limit\" in response.json()[\"detail\"].lower()\n    \n    @patch('src.security.security_utils.rate_limiter.is_allowed')\n    def test_signup_rate_limiting(self, mock_rate_limiter, client):\n        \"\"\"Test rate limiting on signup endpoint.\"\"\"\n        # Mock rate limiter to return False (rate limited)\n        mock_rate_limiter.return_value = False\n        \n        response = client.post(\"/auth/signup\", json={\n            \"email\": \"test@example.com\",\n            \"password\": \"TestPass123!\",\n            \"full_name\": \"Test User\"\n        })\n        \n        assert response.status_code == 429\n        assert \"rate limit\" in response.json()[\"detail\"].lower()\n\n\nclass TestSecurityFeatures:\n    \"\"\"Test security features.\"\"\"\n    \n    def test_input_sanitization(self, client):\n        \"\"\"Test input sanitization.\"\"\"\n        # Try to register with malicious input\n        response = client.post(\"/auth/signup\", json={\n            \"email\": \"test@example.com\",\n            \"password\": \"TestPass123!\",\n            \"full_name\": \"<script>alert('xss')</script>\"\n        })\n        \n        # Should either sanitize or reject\n        if response.status_code == 200:\n            # If accepted, should be sanitized\n            user_data = response.json()[\"user\"]\n            assert \"<script>\" not in user_data[\"full_name\"]\n        else:\n            # If rejected, should be due to validation\n            assert response.status_code in [400, 422]\n    \n    def test_sql_injection_protection(self, client):\n        \"\"\"Test SQL injection protection.\"\"\"\n        # Try login with SQL injection attempt\n        response = client.post(\"/auth/login\", json={\n            \"email\": \"admin'; DROP TABLE users; --\",\n            \"password\": \"TestPass123!\"\n        })\n        \n        # Should be rejected or handled safely\n        assert response.status_code in [400, 401, 422]\n    \n    def test_csrf_protection_headers(self, client):\n        \"\"\"Test CSRF protection headers.\"\"\"\n        response = client.get(\"/auth/me\")\n        \n        # Check for security headers (if middleware is enabled)\n        # This might not be present in test environment\n        # but we can check that the endpoint responds appropriately\n        assert response.status_code in [200, 401]  # Either success or auth required\n\n\nif __name__ == \"__main__\":\n    pytest.main([__file__])\n"