"""
Tests for security middleware functionality.
"""

import pytest
import time
from fastapi import FastAPI, Request
from fastapi.testclient import TestClient
from unittest.mock import Mock, patch
from src.middleware.security_middleware import ComprehensiveSecurityMiddleware
from src.security.security_config import SecurityConfig, SecurityLevel


@pytest.fixture
def security_config():
    \"\"\"Create a test security configuration.\"\"\"\n    return SecurityConfig(\n        environment=\"test\",\n        security_level=SecurityLevel.HIGH,\n        enable_rate_limiting=True,\n        enable_ip_filtering=True,\n        enable_request_validation=True,\n        enable_security_headers=True,\n        enable_csrf_protection=True,\n        rate_limit_requests=10,\n        rate_limit_window=60,\n    )\n\n\n@pytest.fixture\ndef test_app(security_config):\n    \"\"\"Create a test FastAPI app with security middleware.\"\"\"\n    app = FastAPI()\n    \n    # Add security middleware\n    app.add_middleware(\n        ComprehensiveSecurityMiddleware,\n        config=security_config.get_middleware_config()\n    )\n    \n    @app.get(\"/test\")\n    async def test_endpoint():\n        return {\"message\": \"success\"}\n    \n    @app.post(\"/auth/login\")\n    async def login_endpoint():\n        return {\"message\": \"login success\"}\n    \n    return app\n\n\nclass TestSecurityMiddleware:\n    \"\"\"Test security middleware functionality.\"\"\"\n    \n    def test_security_headers_added(self, test_app):\n        \"\"\"Test that security headers are added to responses.\"\"\"\n        client = TestClient(test_app)\n        response = client.get(\"/test\")\n        \n        assert response.status_code == 200\n        assert \"X-Content-Type-Options\" in response.headers\n        assert \"X-Frame-Options\" in response.headers\n        assert \"X-XSS-Protection\" in response.headers\n        assert \"Content-Security-Policy\" in response.headers\n        assert \"Strict-Transport-Security\" in response.headers\n        \n        assert response.headers[\"X-Content-Type-Options\"] == \"nosniff\"\n        assert response.headers[\"X-Frame-Options\"] == \"DENY\"\n        assert response.headers[\"X-XSS-Protection\"] == \"1; mode=block\"\n    \n    def test_suspicious_user_agent_blocked(self, test_app):\n        \"\"\"Test that suspicious user agents are blocked.\"\"\"\n        client = TestClient(test_app)\n        \n        # Test with suspicious user agent\n        response = client.get(\"/test\", headers={\"User-Agent\": \"sqlmap/1.0\"})\n        assert response.status_code == 403\n        assert \"Access denied\" in response.json()[\"detail\"]\n    \n    def test_empty_user_agent_blocked(self, test_app):\n        \"\"\"Test that empty user agents are blocked.\"\"\"\n        client = TestClient(test_app)\n        \n        # Test with empty user agent\n        response = client.get(\"/test\", headers={\"User-Agent\": \"\"})\n        assert response.status_code == 403\n    \n    def test_valid_request_passes(self, test_app):\n        \"\"\"Test that valid requests pass through.\"\"\"\n        client = TestClient(test_app)\n        \n        response = client.get(\"/test\", headers={\"User-Agent\": \"Mozilla/5.0\"})\n        assert response.status_code == 200\n        assert response.json()[\"message\"] == \"success\"\n    \n    def test_large_request_blocked(self, test_app):\n        \"\"\"Test that overly large requests are blocked.\"\"\"\n        client = TestClient(test_app)\n        \n        # Create a large payload\n        large_data = \"x\" * (11 * 1024 * 1024)  # 11MB\n        \n        response = client.post(\n            \"/test\",\n            json={\"data\": large_data},\n            headers={\"User-Agent\": \"Mozilla/5.0\"}\n        )\n        \n        # Should be blocked due to size\n        assert response.status_code == 400\n    \n    def test_path_traversal_blocked(self, test_app):\n        \"\"\"Test that path traversal attempts are blocked.\"\"\"\n        client = TestClient(test_app)\n        \n        # Test path traversal attempt\n        response = client.get(\"/test/../../../etc/passwd\")\n        assert response.status_code == 400\n        assert \"Path traversal attempt detected\" in response.json()[\"detail\"]\n    \n    def test_rate_limiting_works(self, test_app):\n        \"\"\"Test that rate limiting works correctly.\"\"\"\n        client = TestClient(test_app)\n        \n        # Make requests up to the limit\n        for i in range(10):\n            response = client.get(\"/test\", headers={\"User-Agent\": \"Mozilla/5.0\"})\n            assert response.status_code == 200\n        \n        # Next request should be rate limited\n        response = client.get(\"/test\", headers={\"User-Agent\": \"Mozilla/5.0\"})\n        assert response.status_code == 429\n        assert \"Rate limit exceeded\" in response.json()[\"detail\"]\n    \n    def test_sensitive_endpoint_rate_limiting(self, test_app):\n        \"\"\"Test that sensitive endpoints have stricter rate limiting.\"\"\"\n        client = TestClient(test_app)\n        \n        # Login endpoint should have stricter limits\n        for i in range(5):  # Assuming login has limit of 5\n            response = client.post(\"/auth/login\", headers={\"User-Agent\": \"Mozilla/5.0\"})\n            # We expect 200 or other valid response, not 429\n            assert response.status_code != 429\n    \n    def test_invalid_content_type_blocked(self, test_app):\n        \"\"\"Test that invalid content types are blocked for POST requests.\"\"\"\n        client = TestClient(test_app)\n        \n        response = client.post(\n            \"/test\",\n            data=\"invalid data\",\n            headers={\n                \"User-Agent\": \"Mozilla/5.0\",\n                \"Content-Type\": \"text/plain\"\n            }\n        )\n        \n        assert response.status_code == 400\n        assert \"Invalid content type\" in response.json()[\"detail\"]\n    \n    @patch('src.security.security_utils.rate_limiter.is_allowed')\n    def test_rate_limiter_integration(self, mock_rate_limiter, test_app):\n        \"\"\"Test integration with rate limiter.\"\"\"\n        client = TestClient(test_app)\n        \n        # Mock rate limiter to return False (rate limited)\n        mock_rate_limiter.return_value = False\n        \n        response = client.get(\"/test\", headers={\"User-Agent\": \"Mozilla/5.0\"})\n        assert response.status_code == 429\n        \n        # Mock rate limiter to return True (allowed)\n        mock_rate_limiter.return_value = True\n        \n        response = client.get(\"/test\", headers={\"User-Agent\": \"Mozilla/5.0\"})\n        assert response.status_code == 200\n    \n    def test_server_header_removed(self, test_app):\n        \"\"\"Test that server header is removed from responses.\"\"\"\n        client = TestClient(test_app)\n        response = client.get(\"/test\")\n        \n        assert \"server\" not in response.headers\n        assert \"Server\" not in response.headers\n    \n    def test_error_response_format(self, test_app):\n        \"\"\"Test that error responses have consistent format.\"\"\"\n        client = TestClient(test_app)\n        \n        # Trigger an error (suspicious user agent)\n        response = client.get(\"/test\", headers={\"User-Agent\": \"sqlmap\"})\n        \n        assert response.status_code == 403\n        error_data = response.json()\n        \n        assert \"detail\" in error_data\n        assert \"error_code\" in error_data\n        assert \"timestamp\" in error_data\n        assert error_data[\"error_code\"] == \"SEC_403\"\n\n\nclass TestSecurityConfiguration:\n    \"\"\"Test security configuration functionality.\"\"\"\n    \n    def test_security_config_validation(self):\n        \"\"\"Test security configuration validation.\"\"\"\n        config = SecurityConfig(\n            environment=\"production\",\n            jwt_secret_key=\"short\",  # Too short\n        )\n        \n        warnings = config.validate_configuration()\n        assert len(warnings) > 0\n        assert any(\"JWT secret key\" in warning for warning in warnings)\n    \n    def test_security_level_adjustments(self):\n        \"\"\"Test that security level adjusts other settings.\"\"\"\n        config = SecurityConfig(security_level=SecurityLevel.MAXIMUM)\n        \n        assert config.access_token_expire_minutes <= 10\n        assert config.session_timeout_minutes <= 10\n        assert config.password_min_length >= 16\n        assert config.enable_csrf_protection is True\n        assert config.enable_https_only is True\n    \n    def test_rate_limit_config(self):\n        \"\"\"Test rate limit configuration for different endpoints.\"\"\"\n        config = SecurityConfig()\n        \n        login_config = config.get_rate_limit_config('/auth/login')\n        assert 'max_requests' in login_config\n        assert 'window_minutes' in login_config\n        \n        default_config = config.get_rate_limit_config('/api/some-endpoint')\n        assert default_config['max_requests'] == config.default_rate_limit\n    \n    def test_security_headers_config(self):\n        \"\"\"Test security headers configuration.\"\"\"\n        config = SecurityConfig(enable_security_headers=True)\n        headers = config.get_security_headers()\n        \n        assert 'X-Content-Type-Options' in headers\n        assert 'X-Frame-Options' in headers\n        assert 'Content-Security-Policy' in headers\n        \n        config_disabled = SecurityConfig(enable_security_headers=False)\n        headers_disabled = config_disabled.get_security_headers()\n        \n        assert len(headers_disabled) == 0 or 'Strict-Transport-Security' in headers_disabled\n\n\nclass TestInputValidation:\n    \"\"\"Test input validation functionality.\"\"\"\n    \n    def test_sql_injection_detection(self):\n        \"\"\"Test SQL injection pattern detection.\"\"\"\n        from src.security.input_validation import InputValidator\n        \n        # Test malicious queries\n        malicious_queries = [\n            \"'; DROP TABLE users; --\",\n            \"1 OR 1=1\",\n            \"UNION SELECT * FROM passwords\",\n            \"admin'--\",\n            \"' OR 'a'='a\"\n        ]\n        \n        for query in malicious_queries:\n            is_valid, message = InputValidator.validate_sql_query_safety(query)\n            assert not is_valid, f\"Query should be detected as malicious: {query}\"\n    \n    def test_xss_sanitization(self):\n        \"\"\"Test XSS sanitization.\"\"\"\n        from src.security.input_validation import InputValidator\n        \n        malicious_inputs = [\n            \"<script>alert('xss')</script>\",\n            \"javascript:alert('xss')\",\n            \"<img src=x onerror=alert('xss')>\",\n            \"<iframe src='javascript:alert(1)'></iframe>\"\n        ]\n        \n        for malicious_input in malicious_inputs:\n            sanitized = InputValidator.sanitize_string(malicious_input)\n            assert \"<script\" not in sanitized.lower()\n            assert \"javascript:\" not in sanitized.lower()\n            assert \"onerror\" not in sanitized.lower()\n    \n    def test_email_validation(self):\n        \"\"\"Test email validation.\"\"\"\n        from src.security.input_validation import InputValidator\n        \n        # Valid emails\n        valid_emails = [\n            \"user@example.com\",\n            \"test.email@domain.co.uk\",\n            \"user+tag@example.org\"\n        ]\n        \n        for email in valid_emails:\n            is_valid, message = InputValidator.validate_email(email)\n            assert is_valid, f\"Email should be valid: {email}\"\n        \n        # Invalid emails\n        invalid_emails = [\n            \"invalid-email\",\n            \"@example.com\",\n            \"user@\",\n            \"user..name@example.com\",\n            \"a\" * 255 + \"@example.com\"  # Too long\n        ]\n        \n        for email in invalid_emails:\n            is_valid, message = InputValidator.validate_email(email)\n            assert not is_valid, f\"Email should be invalid: {email}\"\n    \n    def test_password_validation(self):\n        \"\"\"Test password strength validation.\"\"\"\n        from src.security.input_validation import InputValidator\n        \n        # Strong passwords\n        strong_passwords = [\n            \"StrongP@ssw0rd123\",\n            \"MySecure#Password1\",\n            \"C0mpl3x!P@ssw0rd\"\n        ]\n        \n        for password in strong_passwords:\n            is_valid, errors = InputValidator.validate_password(password)\n            assert is_valid, f\"Password should be valid: {password}, errors: {errors}\"\n        \n        # Weak passwords\n        weak_passwords = [\n            \"password\",  # Too common\n            \"123456\",    # Too simple\n            \"short\",     # Too short\n            \"nouppercase1!\",  # No uppercase\n            \"NOLOWERCASE1!\",  # No lowercase\n            \"NoNumbers!\",     # No numbers\n            \"NoSpecialChars1\" # No special chars\n        ]\n        \n        for password in weak_passwords:\n            is_valid, errors = InputValidator.validate_password(password)\n            assert not is_valid, f\"Password should be invalid: {password}\"\n            assert len(errors) > 0\n    \n    def test_file_upload_validation(self):\n        \"\"\"Test file upload validation.\"\"\"\n        from src.security.input_validation import InputValidator\n        \n        # Valid file\n        valid_content = b\"This is a valid text file content.\"\n        is_valid, message = InputValidator.validate_file_upload(\n            \"document.txt\", \n            valid_content, \n            ['.txt', '.pdf']\n        )\n        assert is_valid\n        \n        # Invalid extension\n        is_valid, message = InputValidator.validate_file_upload(\n            \"script.exe\", \n            valid_content, \n            ['.txt', '.pdf']\n        )\n        assert not is_valid\n        assert \"not allowed\" in message\n        \n        # Malicious content\n        malicious_content = b\"<script>alert('xss')</script>\"\n        is_valid, message = InputValidator.validate_file_upload(\n            \"malicious.txt\", \n            malicious_content, \n            ['.txt']\n        )\n        assert not is_valid\n        assert \"malicious content\" in message.lower()\n\n\nif __name__ == \"__main__\":\n    pytest.main([__file__])\n"